<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Family Tree</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .node-box {
      border: 1px solid #3b82f6; /* blue-500 */
      padding: 4px 8px;
      border-radius: 6px;
      background: white;
      display: inline-block;
      cursor: pointer;
      user-select: none;
      max-width: max-content;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: 600;
      font-size: 0.875rem;
      /* fixed width but adaptive to content */
      min-width: 6ch;
      max-width: 14ch;
    }
    .node-box.highlight {
      background-color: #fde68a; /* yellow-300 */
    }
    .blink-highlight {
      animation: blink-highlight 1.5s infinite;
    }
    @keyframes blink-highlight {
      0%, 100% { background-color: #fef3c7; }
      50% { background-color: #facc15; }
    }
    .tree-node-container {
      margin-left: 12px;
      border-left: 2px solid #3b82f6;
      padding-left: 10px;
    }
    .spouse-box {
      border: 1px solid #22c55e; /* green-500 */
      padding: 2px 6px;
      border-radius: 4px;
      background: white;
      display: inline-block;
      margin-right: 6px;
      cursor: pointer;
      font-size: 0.8rem;
      max-width: max-content;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 5ch;
      max-width: 12ch;
    }
    .spouse-box.highlight {
      background-color: #bbf7d0; /* green-200 */
    }
    .spouse-box.blink-highlight {
      animation: blink-highlight 1.5s infinite;
    }
    input[type="text"], input[type="date"] {
      font-size: 0.85rem;
      padding: 1px 4px;
      border-radius: 4px;
      border: 1px solid #9ca3af; /* gray-400 */
      max-width: 12ch;
    }
    .toggle-expand-btn {
      margin-bottom: 10px;
      background-color: #3b82f6;
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      user-select: none;
      border: none;
    }
  </style>
</head>
<body class="bg-gray-50 p-6">
  <div id="root" class="max-w-5xl mx-auto"></div>

  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.20.0/firebase-database-compat.js"></script>

  <script>
    const { useState, useEffect, useRef } = React;

    // Initialize Firebase (replace with your own config)
    const firebaseConfig = {
      apiKey: "AIzaSyCy9CKJ6CELheBhw7Gs0BgsE1E0FsoYdgU",
      authDomain: "project-955237504610034331.firebaseapp.com",
      databaseURL: "https://project-955237504610034331-default-rtdb.firebaseio.com",
      projectId: "project-955237504610034331",
      storageBucket: "project-955237504610034331.firebasestorage.app",
      messagingSenderId: "76212939677",
      appId: "1:76212939677:web:cc36cc1cadfd106b6e5d74",
      measurementId: "G-RCJ4P82PVM"
    };
    const app = firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    // EditableField component for birthday/deathday inputs
    function EditableField({ label, type, value, onChange }) {
      return (
        <label className="mr-3">
          <span className="text-gray-600">{label}: </span>
          <input
            type={type}
            value={value}
            onChange={e => onChange(e.target.value)}
            className="inline-block"
          />
        </label>
      );
    }

    // Spouse item box
    function SpouseItem({ spouse, onUpdate, onDelete, highlight, blink }) {
      const [editName, setEditName] = useState(false);
      const [tempName, setTempName] = useState(spouse.name || "");

      useEffect(() => {
        setTempName(spouse.name || "");
      }, [spouse.name]);

      function saveName() {
        onUpdate({ ...spouse, name: tempName });
        setEditName(false);
      }

      return (
        <div
          className={`spouse-box ${highlight ? "highlight" : ""} ${
            blink ? "blink-highlight" : ""
          }`}
          title="Double-click to edit, click × to delete"
        >
          {editName ? (
            <input
              type="text"
              value={tempName}
              onChange={e => setTempName(e.target.value)}
              onBlur={saveName}
              onKeyDown={e => { if (e.key === "Enter") saveName(); }}
              autoFocus
            />
          ) : (
            <span onDoubleClick={() => setEditName(true)}>{spouse.name || <em className="text-gray-400">(unnamed)</em>}</span>
          )}
          <button
            onClick={e => {
              e.stopPropagation();
              onDelete(spouse.id);
            }}
            className="ml-2 text-red-600 font-bold select-none"
            title="Delete spouse"
          >
            ×
          </button>
        </div>
      );
    }

    // TreeNode component
    let nextId = 1000; // for new nodes/spouses id generation

    function TreeNode({
      node,
      onUpdate,
      onDelete,
      highlightIds,
      blinkIds,
      openIds,
      scrollToId,
      onScrollHandled,
    }) {
      const [open, setOpen] = useState(true);
      const [editName, setEditName] = useState(false);
      const [tempName, setTempName] = useState(node.name || "");
      const ref = useRef(null);

      useEffect(() => {
        setTempName(node.name || "");
      }, [node.name]);

      useEffect(() => {
        setOpen(openIds.has(node.id));
      }, [openIds, node.id]);

      useEffect(() => {
        if (scrollToId === node.id && ref.current) {
          ref.current.scrollIntoView({ behavior: "smooth", block: "center" });
          onScrollHandled();
        }
      }, [scrollToId, node.id, onScrollHandled]);

      function saveName() {
        onUpdate({ ...node, name: tempName });
        setEditName(false);
      }

      function updateField(field, val) {
        onUpdate({ ...node, [field]: val });
      }

      function addChild() {
        const newChild = {
          id: nextId++,
          name: "",
          birthday: "",
          deathday: "",
          spouses: [],
          children: [],
        };
        const updated = {
          ...node,
          children: [...(node.children || []), newChild],
        };
        onUpdate(updated);
        setOpen(true);
      }

      function addSpouse() {
        const newSpouse = {
          id: nextId++,
          name: "",
          birthday: "",
          deathday: "",
        };
        const updated = {
          ...node,
          spouses: [...(node.spouses || []), newSpouse],
        };
        onUpdate(updated);
      }

      function updateChild(updatedChild) {
        const updated = {
          ...node,
          children: (node.children || []).map(c => (c.id === updatedChild.id ? updatedChild : c)),
        };
        onUpdate(updated);
      }

      function deleteChild(childId) {
        const updated = {
          ...node,
          children: (node.children || []).filter(c => c.id !== childId),
        };
        onUpdate(updated);
      }

      function updateSpouse(updatedSpouse) {
        const updated = {
          ...node,
          spouses: (node.spouses || []).map(s => (s.id === updatedSpouse.id ? updatedSpouse : s)),
        };
        onUpdate(updated);
      }

      function deleteSpouse(spouseId) {
        const updated = {
          ...node,
          spouses: (node.spouses || []).filter(s => s.id !== spouseId),
        };
        onUpdate(updated);
      }

      const isHighlighted = highlightIds.has(node.id);
      const isBlinking = blinkIds.has(node.id);

      return (
        <div ref={ref} className="mb-2">
          <div
            className={`node-box ${
              isHighlighted ? "highlight" : ""
            } ${isBlinking ? "blink-highlight" : ""}`}
            onClick={() => setOpen(!open)}
            title="Click to expand/collapse"
          >
            {editName ? (
              <input
                type="text"
                value={tempName}
                onChange={e => setTempName(e.target.value)}
                onBlur={saveName}
                onKeyDown={e => { if (e.key === "Enter") saveName(); }}
                autoFocus
                className="border border-gray-400 rounded px-1 py-0.5 w-full max-w-[14ch]"
              />
            ) : (
              <span onDoubleClick={() => setEditName(true)}>
                {node.name || <em className="text-gray-400">(unnamed)</em>}
              </span>
            )}
            <div className="mt-1 flex flex-wrap gap-2 text-xs text-gray-600 items-center">
              <EditableField
                label="Bday"
                type="date"
                value={node.birthday}
                onChange={val => updateField("birthday", val)}
              />
              <EditableField
                label="Dday"
                type="date"
                value={node.deathday}
                onChange={val => updateField("deathday", val)}
              />
              <button
                onClick={e => { e.stopPropagation(); onDelete(node.id); }}
                className="ml-auto text-red-600 hover:text-red-800 font-bold select-none"
                title="Delete node"
              >
                ×
              </button>
            </div>
            <div className="mt-1">
              <button
                onClick={e => { e.stopPropagation(); addChild(); }}
                className="mr-2 text-blue-600 hover:text-blue-800 text-xs font-semibold"
                title="Add child"
              >
                + Child
              </button>
              <button
                onClick={e => { e.stopPropagation(); addSpouse(); }}
                className="text-green-600 hover:text-green-800 text-xs font-semibold"
                title="Add spouse"
              >
                + Spouse
              </button>
            </div>
          </div>

          {/* Spouses */}
          {open && node.spouses && node.spouses.length > 0 && (
            <div className="pl-6 mt-1 space-y-1">
              {node.spouses.map(spouse => (
                <SpouseItem
                  key={spouse.id}
                  spouse={spouse}
                  onUpdate={updateSpouse}
                  onDelete={deleteSpouse}
                  highlight={highlightIds.has(spouse.id)}
                  blink={blinkIds.has(spouse.id)}
                />
              ))}
            </div>
          )}

          {/* Children */}
          {open && node.children && node.children.length > 0 && (
            <div className="tree-node-container mt-2 pl-4 border-l-2 border-blue-400">
              {node.children.map(child => (
                <TreeNode
                  key={child.id}
                  node={child}
                  onUpdate={updateChild}
                  onDelete={deleteChild}
                  highlightIds={highlightIds}
                  blinkIds={blinkIds}
                  openIds={openIds}
                  scrollToId={scrollToId}
                  onScrollHandled={onScrollHandled}
                />
              ))}
            </div>
          )}
        </div>
      );
    }

    function FamilyTreeApp() {
      const [treeData, setTreeData] = useState(null);
      const [search, setSearch] = useState("");
      const [highlightIds, setHighlightIds] = useState(new Set());
      const [blinkIds, setBlinkIds] = useState(new Set());
      const [openIds, setOpenIds] = useState(new Set());
      const [scrollToId, setScrollToId] = useState(null);
      const [expandAll, setExpandAll] = useState(true);

      // Load data from Firebase on mount
      useEffect(() => {
        const dbRef = firebase.database().ref("/tree");
        dbRef.on("value", (snapshot) => {
          const val = snapshot.val();
          if (val) {
            setTreeData(val);
          } else {
            const rootNode = {
              id: 1,
              name: "Root Person",
              birthday: "1970-01-01",
              deathday: "",
              spouses: [],
              children: [],
            };
            setTreeData(rootNode);
            firebase.database().ref("/tree").set(rootNode);
          }
        });
        return () => dbRef.off();
      }, []);

      // Save data to Firebase when treeData changes (debounced)
      useEffect(() => {
        if (!treeData) return;
        const timeout = setTimeout(() => {
          firebase.database().ref("/tree").set(treeData);
        }, 300);
        return () => clearTimeout(timeout);
      }, [treeData]);

      // Flatten tree (nodes and spouses) to array
      function flattenTree(node) {
        let arr = [node];
        (node.children || []).forEach(child => {
          arr = arr.concat(flattenTree(child));
        });
        (node.spouses || []).forEach(spouse => {
          arr.push(spouse);
        });
        return arr;
      }

      // Find node in tree by id
      function findNodeById(node, id) {
        if (node.id === id) return node;
        for (const child of (node.children || [])) {
          const found = findNodeById(child, id);
          if (found) return found;
        }
        return null;
      }

      // Find parents of a node by id (return array of parent nodes)
      function findParents(targetId, root, parents = []) {
        if (!root) return null;
        if ((root.children || []).some(c => c.id === targetId)) {
          parents.push(root);
          return parents;
        }
        for (const child of (root.children || [])) {
          const res = findParents(targetId, child, parents);
          if (res) {
            parents.push(root);
            return parents;
          }
        }
        return null;
      }

      // Collect all ancestor IDs (parents, grandparents, etc.) recursively for a given node
      function collectAncestorIds(nodeId, root) {
        const parents = findParents(nodeId, root, []);
        if (!parents) return [];
        // parents array is collected bottom-up, reverse to top-down
        const reversed = [...parents].reverse();
        // recursively collect ancestors for each parent
        const allAncestors = new Set();
        for (const p of reversed) {
          allAncestors.add(p.id);
          const higherAncestors = collectAncestorIds(p.id, root);
          higherAncestors.forEach(id => allAncestors.add(id));
        }
        return Array.from(allAncestors);
      }

      // Search and update highlights + blinking + open states
      useEffect(() => {
        if (!treeData) return;

        if (!search.trim()) {
          setHighlightIds(new Set());
          setBlinkIds(new Set());
          setOpenIds(expandAll ? collectAllNodeIds(treeData) : new Set());
          setScrollToId(null);
          return;
        }

        const allNodes = flattenTree(treeData);
        const lowerSearch = search.trim().toLowerCase();

        // Find matched nodes
        const matchedNodes = allNodes.filter(n => n.name?.toLowerCase().includes(lowerSearch));

        if (matchedNodes.length === 0) {
          setHighlightIds(new Set());
          setBlinkIds(new Set());
          setOpenIds(new Set());
          setScrollToId(null);
          return;
        }

        // IDs to highlight = matched nodes + their ancestors + spouses of matched nodes
        const highlightSet = new Set();
        const blinkSet = new Set();

        matchedNodes.forEach(n => {
          highlightSet.add(n.id);

          // Add spouses of matched nodes (if node is not spouse)
          if (!n.spouses) {
            // node, find its spouses by searching tree for parent containing this node as spouse
            // but since we flattened spouses as separate, if n is spouse, skip
            // Else, add spouses of the matched node if exists
            // Let's add spouses of matched node if it's a node
            const parentNode = findParentOfSpouse(n.id, treeData);
            if (parentNode) {
              parentNode.spouses.forEach(s => highlightSet.add(s.id));
            }
          } else {
            // If n is a main node, add spouses too
            (n.spouses || []).forEach(s => highlightSet.add(s.id));
          }

          // Add ancestors (parents, grandparents, etc.)
          const ancestors = collectAncestorIds(n.id, treeData);
          ancestors.forEach(id => highlightSet.add(id));
        });

        // Blink only the matched nodes themselves (not ancestors)
        matchedNodes.forEach(n => blinkSet.add(n.id));

        // Open all ancestors + matched nodes
        const openSet = new Set();
        matchedNodes.forEach(n => {
          openSet.add(n.id);
          const ancestors = collectAncestorIds(n.id, treeData);
          ancestors.forEach(id => openSet.add(id));
        });

        setHighlightIds(highlightSet);
        setBlinkIds(blinkSet);
        setOpenIds(openSet);

        // Auto scroll to first matched node
        setScrollToId(matchedNodes[0].id);
      }, [search, treeData, expandAll]);

      // Helper: collect all node IDs recursively (exclude spouses)
      function collectAllNodeIds(node) {
        let ids = new Set([node.id]);
        (node.children || []).forEach(c => {
          collectAllNodeIds(c).forEach(id => ids.add(id));
        });
        return ids;
      }

      // Find parent node of a spouse by spouse id
      function findParentOfSpouse(spouseId, node) {
        if (!node) return null;
        if ((node.spouses || []).some(s => s.id === spouseId)) return node;
        for (const child of (node.children || [])) {
          const found = findParentOfSpouse(spouseId, child);
          if (found) return found;
        }
        return null;
      }

      // Update root tree data with new data for a node with given id
      function updateNode(updatedNode, currentNode = treeData) {
        if (!currentNode) return currentNode;
        if (currentNode.id === updatedNode.id) return updatedNode;
        return {
          ...currentNode,
          children: (currentNode.children || []).map(c => updateNode(updatedNode, c)),
        };
      }

      // Delete a node by id (returns updated tree or null if root deleted)
      function deleteNodeById(idToDelete, currentNode = treeData) {
        if (!currentNode) return null;
        if (currentNode.id === idToDelete) return null;
        return {
          ...currentNode,
          children: (currentNode.children || [])
            .map(c => deleteNodeById(idToDelete, c))
            .filter(Boolean),
        };
      }

      function handleUpdateNode(updatedNode) {
        setTreeData(prev => updateNode(updatedNode, prev));
      }

      function handleDeleteNode(id) {
        if (id === treeData.id) {
          if (!confirm("Delete root node? This will clear the entire tree.")) return;
          setTreeData(null);
          firebase.database().ref("/tree").remove();
          return;
        }
        setTreeData(prev => deleteNodeById(id, prev));
      }

      function handleToggleExpandAll() {
        if (expandAll) {
          setOpenIds(new Set());
        } else {
          setOpenIds(collectAllNodeIds(treeData));
        }
        setExpandAll(!expandAll);
      }

      return (
        <div>
          <div className="mb-4 flex items-center gap-4">
            <input
              type="text"
              placeholder="Search by name..."
              value={search}
              onChange={e => setSearch(e.target.value)}
              className="border border-gray-300 rounded px-3 py-1 w-72"
            />
            <button
              onClick={handleToggleExpandAll}
              className="toggle-expand-btn"
            >
              {expandAll ? "Collapse All" : "Expand All"}
            </button>
          </div>

          {treeData ? (
            <TreeNode
              node={treeData}
              onUpdate={handleUpdateNode}
              onDelete={handleDeleteNode}
              highlightIds={highlightIds}
              blinkIds={blinkIds}
              openIds={openIds}
              scrollToId={scrollToId}
              onScrollHandled={() => setScrollToId(null)}
            />
          ) : (
            <div className="text-gray-500 italic">No tree data available.</div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<FamilyTreeApp />);
  </script>
</body>
</html>
