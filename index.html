<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Firebase Group & Private Chat Demo</title>
<style>
  /* Reset & layout */
  body, html {
    margin:0; padding:0; height:100%;
    font-family: Arial, sans-serif;
    display: flex; flex-direction: column;
  }
  header, footer {
    background: #222; color: #eee;
    padding: 0.6em 1em;
    text-align: center;
  }
  main {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 1em;
    max-width: 700px;
    margin: auto;
    width: 100%;
  }

  /* Login/Register */
  #loginSection, #chatSection {
    border: 1px solid #ccc;
    padding: 1em;
    border-radius: 6px;
    background: #fafafa;
  }
  #loginSection input {
    width: 100%;
    padding: 0.5em;
    margin: 0.3em 0 1em 0;
    font-size: 1em;
  }
  #loginSection button {
    width: 100%;
    padding: 0.6em;
    font-size: 1em;
  }

  /* Chat UI */
  #chatControls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.7em;
    margin-bottom: 1em;
  }
  select, input[type="text"] {
    padding: 0.4em 0.6em;
    font-size: 1em;
  }
  #displayNameInput {
    flex: 1 1 300px;
    font-size: 1.1em;
    padding: 0.4em 0.6em;
  }
  #displayNameSaveBtn {
    padding: 0.3em 0.8em;
    font-size: 0.9em;
  }
  #groupCreateInput {
    flex: 1 1 200px;
  }
  #createGroupBtn {
    padding: 0.3em 0.7em;
    font-size: 0.9em;
  }

  /* Messages area */
  #messages {
    flex: 1;
    min-height: 300px;
    max-height: 400px;
    border: 1px solid #bbb;
    border-radius: 6px;
    background: white;
    overflow-y: auto;
    padding: 0.7em;
    display: flex;
    flex-direction: column;
  }
  .message {
    max-width: 75%;
    padding: 0.4em 0.7em;
    margin-bottom: 0.8em;
    border-radius: 10px;
    word-wrap: break-word;
    position: relative;
  }
  .message.self {
    background: #cce5ff;
    align-self: flex-end;
  }
  .message.other {
    background: #eee;
    align-self: flex-start;
  }
  .sender {
    font-weight: bold;
    font-size: 0.85em;
    margin-bottom: 0.2em;
  }
  .timestamp {
    font-size: 0.7em;
    color: #666;
    text-align: right;
    margin-top: 0.2em;
  }

  /* Typing indicator */
  #typingIndicator {
    height: 20px;
    font-style: italic;
    color: #555;
    margin: 0.3em 0 0.7em 0;
    min-height: 18px;
  }

  /* Message input */
  #messageInput {
    width: 100%;
    min-height: 3em;
    max-height: 6em;
    padding: 0.5em;
    font-size: 1em;
    resize: vertical;
    border-radius: 6px;
    border: 1px solid #bbb;
  }
  #sendBtn {
    margin-top: 0.5em;
    padding: 0.6em 1.2em;
    font-size: 1em;
    cursor: pointer;
    background: #3578e5;
    color: white;
    border: none;
    border-radius: 6px;
  }

</style>
</head>
<body>

<header><h2>Firebase Chat (1-on-1 & Groups)</h2></header>

<main>

<section id="loginSection">
  <h3>Login or Register</h3>
  <input type="email" id="emailInput" placeholder="Email" autocomplete="username" />
  <input type="password" id="passwordInput" placeholder="Password" autocomplete="current-password" />
  <button id="loginBtn">Login</button>
  <button id="registerBtn">Register</button>
  <p id="loginMsg" style="color:red;"></p>
</section>

<section id="chatSection" style="display:none; flex-direction: column; height: 100%;">
  <div id="chatControls">

    <input id="displayNameInput" placeholder="Set your display name" title="Display Name" />
    <button id="displayNameSaveBtn" title="Save Display Name">Save</button>

    <select id="userSelect" title="Select user to chat"></select>
    <select id="groupSelect" title="Select group to chat"></select>

    <input type="text" id="groupCreateInput" placeholder="New group name" />
    <button id="createGroupBtn">Create Group</button>
  </div>

  <div id="messages"></div>
  <div id="typingIndicator"></div>
  <textarea id="messageInput" placeholder="Type a message... (Enter to send, Shift+Enter newline)"></textarea>
  <button id="sendBtn">Send</button>
</section>

</main>

<footer>&copy; 2025 Maki Web. All rights reserved</footer>

<!-- Firebase SDKs -->
<script type="module">
  // Import Firebase modular SDK
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-analytics.js";
  import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-auth.js";
  import { getDatabase, ref, onValue, set, push, update, get, child, remove } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCy9CKJ6CELheBhw7Gs0BgsE1E0FsoYdgU",
    authDomain: "project-955237504610034331.firebaseapp.com",
    projectId: "project-955237504610034331",
    storageBucket: "project-955237504610034331.firebasestorage.app",
    messagingSenderId: "76212939677",
    appId: "1:76212939677:web:ef498bc1e4e480ab6e5d74",
    measurementId: "G-WXBEP1LXTX"
  };

  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  const auth = getAuth(app);
  const db = getDatabase(app);

  // UI Elements
  const loginSection = document.getElementById('loginSection');
  const chatSection = document.getElementById('chatSection');
  const emailInput = document.getElementById('emailInput');
  const passwordInput = document.getElementById('passwordInput');
  const loginBtn = document.getElementById('loginBtn');
  const registerBtn = document.getElementById('registerBtn');
  const loginMsg = document.getElementById('loginMsg');

  const displayNameInput = document.getElementById('displayNameInput');
  const displayNameSaveBtn = document.getElementById('displayNameSaveBtn');

  const userSelect = document.getElementById('userSelect');
  const groupSelect = document.getElementById('groupSelect');
  const groupCreateInput = document.getElementById('groupCreateInput');
  const createGroupBtn = document.getElementById('createGroupBtn');

  const messagesDiv = document.getElementById('messages');
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const typingIndicator = document.getElementById('typingIndicator');

  let allUsers = {};
  let allGroups = {};
  let currentChatId = null;
  let currentChatType = null; // 'user' or 'group'
  let typingTimeout;
  let typingUsers = {};
  let unsubscribeMessages = null;
  let unsubscribeTyping = null;

  // UTIL: Format timestamp
  function formatTimestamp(ts) {
    const d = new Date(ts);
    return d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  }

  // UTIL: Scroll messages to bottom
  function scrollMessagesToBottom() {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  // AUTH EVENTS
  loginBtn.onclick = () => {
    loginMsg.textContent = "";
    const email = emailInput.value.trim();
    const pass = passwordInput.value;
    if (!email || !pass) {
      loginMsg.textContent = "Please enter email and password";
      return;
    }
    signInWithEmailAndPassword(auth, email, pass)
      .catch(e => loginMsg.textContent = e.message);
  };

  registerBtn.onclick = () => {
    loginMsg.textContent = "";
    const email = emailInput.value.trim();
    const pass = passwordInput.value;
    if (!email || !pass) {
      loginMsg.textContent = "Please enter email and password";
      return;
    }
    createUserWithEmailAndPassword(auth, email, pass)
      .catch(e => loginMsg.textContent = e.message);
  };

  // ON AUTH STATE CHANGED
  onAuthStateChanged(auth, async user => {
    if(user) {
      loginSection.style.display = "none";
      chatSection.style.display = "flex";
      await loadUsersAndGroups();
      await loadDisplayName();
      initChatUI();
    } else {
      loginSection.style.display = "block";
      chatSection.style.display = "none";
      clearUI();
    }
  });

  // Load users and groups for selects
  async function loadUsersAndGroups() {
    // Load users
    const usersSnap = await get(ref(db, "users"));
    allUsers = usersSnap.val() || {};
    // Remove current user from userSelect
    userSelect.innerHTML = '<option value="">-- Select user --</option>';
    Object.entries(allUsers).forEach(([uid,user]) => {
      if(uid !== auth.currentUser.uid)
        userSelect.insertAdjacentHTML('beforeend', `<option value="${uid}">${user.displayName || uid}</option>`);
    });

    // Load groups
    const groupsSnap = await get(ref(db, "groups"));
    allGroups = groupsSnap.val() || {};
    groupSelect.innerHTML = '<option value="">-- Select group --</option>';
    Object.entries(allGroups).forEach(([gid, group]) => {
      // Only show groups user is a member of
      if(group.members && group.members[auth.currentUser.uid]) {
        groupSelect.insertAdjacentHTML('beforeend', `<option value="${gid}">${group.name}</option>`);
      }
    });
  }

  // Load current user display name
  async function loadDisplayName() {
    const uid = auth.currentUser.uid;
    const snap = await get(ref(db, `users/${uid}/displayName`));
    const name = snap.val() || "";
    displayNameInput.value = name;
  }

  displayNameSaveBtn.onclick = async () => {
    const newName = displayNameInput.value.trim();
    if (!newName) {
      alert("Display name cannot be empty");
      return;
    }
    const uid = auth.currentUser.uid;
    try {
      await set(ref(db, `users/${uid}/displayName`), newName);
      alert("Display name updated!");
      await loadUsersAndGroups();
    } catch(e) {
      alert("Failed to update display name: " + e.message);
    }
  };

  // Create group
  createGroupBtn.onclick = async () => {
    const groupName = groupCreateInput.value.trim();
    if (!groupName) {
      alert("Group name cannot be empty");
      return;
    }
    const newGroupRef = push(ref(db, "groups"));
    const groupId = newGroupRef.key;
    const uid = auth.currentUser.uid;
    const groupData = {
      name: groupName,
      members: { [uid]: true }
    };
    await set(newGroupRef, groupData);
    groupCreateInput.value = "";
    await loadUsersAndGroups();
    groupSelect.value = groupId;
    switchChat('group', groupId);
  };

  // Switch chat handler
  userSelect.onchange = () => {
    if (userSelect.value) {
      groupSelect.value = "";
      const chatId = [auth.currentUser.uid, userSelect.value].sort().join("_");
      switchChat("user", chatId);
    }
  };

  groupSelect.onchange = () => {
    if (groupSelect.value) {
      userSelect.value = "";
      switchChat("group", groupSelect.value);
    }
  };

  // Switch chat logic
  async function switchChat(type, chatId) {
    if (unsubscribeMessages) unsubscribeMessages();
    if (unsubscribeTyping) unsubscribeTyping();
    currentChatId = chatId;
    currentChatType = type;
    messagesDiv.innerHTML = "";
    typingIndicator.textContent = "";

    // Listen to messages
    const messagesRef = ref(db, `messages/${chatId}`);
    unsubscribeMessages = onValue(messagesRef, snap => {
      const msgs = snap.val() || {};
      messagesDiv.innerHTML = "";
      Object.entries(msgs).sort((a,b) => a[1].timestamp - b[1].timestamp).forEach(([mid,msg]) => {
        displayMessage(msg);
      });
      scrollMessagesToBottom();
    });

    // Listen to typing
    const typingRef = ref(db, `typing/${chatId}`);
    unsubscribeTyping = onValue(typingRef, snap => {
      const typingUsersData = snap.val() || {};
      typingUsers = Object.assign({}, typingUsersData);
      delete typingUsers[auth.currentUser.uid]; // exclude self
      const names = Object.keys(typingUsers).map(uid => allUsers[uid]?.displayName || uid);
      if(names.length > 0) {
        typingIndicator.textContent = names.join(", ") + (names.length > 1 ? " are typing..." : " is typing...");
      } else {
        typingIndicator.textContent = "";
      }
    });
  }

  // Display a message in chat window
  function displayMessage(msg) {
    const div = document.createElement("div");
    div.classList.add("message");
    if (msg.sender === auth.currentUser.uid) {
      div.classList.add("self");
    } else {
      div.classList.add("other");
    }
    // Sender name
    const senderName = msg.senderName || allUsers[msg.sender]?.displayName || msg.sender;
    div.innerHTML = `<div class="sender">${senderName}</div><div class="text">${escapeHtml(msg.text)}</div><div class="timestamp">${formatTimestamp(msg.timestamp)}</div>`;
    messagesDiv.appendChild(div);
  }

  // Escape HTML to avoid injection
  function escapeHtml(text) {
    return text.replace(/[&<>"']/g, function(m) {
      return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m];
    });
  }

  // Send message handler
  async function sendMessage() {
    const text = messageInput.value.trim();
    if(!text || !currentChatId) return;
    const uid = auth.currentUser.uid;
    const senderName = allUsers[uid]?.displayName || uid;
    const newMsgRef = push(ref(db, `messages/${currentChatId}`));
    const msgData = {
      sender: uid,
      senderName,
      text,
      timestamp: Date.now()
    };
    await set(newMsgRef, msgData);
    messageInput.value = "";
    await sendNotificationToRecipients(msgData);
  }

  sendBtn.onclick = sendMessage;

  // Press Enter to send, Shift+Enter newline
  messageInput.addEventListener('keydown', e => {
    if(e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  // Typing status management
  messageInput.addEventListener('input', () => {
    if(!currentChatId) return;
    const uid = auth.currentUser.uid;
    const typingRef = ref(db, `typing/${currentChatId}/${uid}`);
    set(typingRef, true);
    clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => {
      remove(typingRef);
    }, 2000);
  });

  // Send push notification to recipients via Cloud Function
  async function sendNotificationToRecipients(msg) {
    const senderId = auth.currentUser.uid;
    let recipients = [];

    if(currentChatType === "user") {
      const otherUser = currentChatId.split("_").filter(u => u !== senderId)[0];
      recipients = [otherUser];
    } else if(currentChatType === "group") {
      const group = allGroups[currentChatId];
      if(group && group.members) {
        recipients = Object.keys(group.members).filter(uid => uid !== senderId);
      }
    }

    recipients.forEach(async uid => {
      try {
        // You must store user FCM tokens at: fcmTokens/{uid} in your Realtime DB
        const tokenSnap = await get(ref(db, `fcmTokens/${uid}`));
        const token = tokenSnap.val();
        if(token) {
          await fetch("YOUR_CLOUD_FUNCTION_URL", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              token,
              title: `${msg.senderName} sent a message`,
              body: msg.text
            }),
          });
        }
      } catch(e) {
        console.warn("Failed to send notification", e);
      }
    });
  }

  // Clear UI on logout
  function clearUI() {
    displayNameInput.value = "";
    userSelect.innerHTML = "";
    groupSelect.innerHTML = "";
    messagesDiv.innerHTML = "";
    typingIndicator.textContent = "";
    messageInput.value = "";
    currentChatId = null;
    currentChatType = null;
    allUsers = {};
    allGroups = {};
    if(unsubscribeMessages) unsubscribeMessages();
    if(unsubscribeTyping) unsubscribeTyping();
  }

  // Initialize chat UI after login
  function initChatUI() {
    // Load users & groups already done in onAuthStateChanged
    userSelect.value = "";
    groupSelect.value = "";
    messagesDiv.innerHTML = "";
    typingIndicator.textContent = "";
    messageInput.value = "";
    currentChatId = null;
    currentChatType = null;
  }

</script>

</body>
</html>
