<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Family Tree with Firebase</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
    import { getDatabase, ref, onValue, set, update } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-database.js";

    window.firebaseImports = { initializeApp, getDatabase, ref, onValue, set, update };
  </script>
  <style>
    .highlight {
      background-color: #ffe58f;
      border-radius: 0.25rem;
      box-shadow: 0 0 8px 2px #ffd666aa;
      animation: none;
    }

    .blink-highlight {
      animation: blink 1s infinite;
      background-color: #ffd666;
      border-radius: 0.25rem;
      box-shadow: 0 0 8px 2px #ffb700cc;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .children-container {
      transition: max-height 0.3s ease, opacity 0.3s ease;
      overflow: hidden;
    }

    /* Box style for nodes and spouses */
    .node-box {
      border: 2px solid #93c5fd; /* Tailwind blue-400 */
      border-radius: 0.5rem;
      padding: 0.25rem 0.5rem;
      margin-bottom: 0.5rem;
      background: white;
      display: inline-block;
      box-shadow: 0 2px 6px rgb(147 197 253 / 0.5);
      position: relative;
      max-width: max-content;
      min-width: 0;
      white-space: nowrap;
    }

    /* Lines connecting nodes */
    .tree-node-container {
      border-left: 2px solid #93c5fd;
      margin-left: 1rem;
      padding-left: 1rem;
    }

    /* Scroll container */
    #tree-scroll-container {
      width: 100%;
      max-width: 100vw;
      height: 70vh;
      overflow: auto;
      border: 1px solid #cbd5e1; /* Tailwind gray-300 */
      border-radius: 0.5rem;
      padding: 1rem;
      background: #f9fafb;
      box-sizing: border-box;
      user-select: none;
    }

    /* Buttons */
    .toggle-expand-btn {
      margin-bottom: 1rem;
      padding: 0.5rem 1rem;
      background-color: #3b82f6; /* blue-500 */
      color: white;
      font-weight: 600;
      border-radius: 0.375rem;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.2s ease;
    }
    .toggle-expand-btn:hover {
      background-color: #2563eb; /* blue-600 */
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center p-4">
  <div id="root" class="w-full max-w-6xl bg-white p-6 rounded shadow"></div>

  <script type="text/babel">

    const { useState, useEffect, useRef } = React;

    // Firebase config - replace with your own or use this one
    const firebaseConfig = {
      apiKey: "AIzaSyCy9CKJ6CELheBhw7Gs0BgsE1E0FsoYdgU",
      authDomain: "project-955237504610034331.firebaseapp.com",
      databaseURL: "https://project-955237504610034331-default-rtdb.firebaseio.com",
      projectId: "project-955237504610034331",
      storageBucket: "project-955237504610034331.firebasestorage.app",
      messagingSenderId: "76212939677",
      appId: "1:76212939677:web:cc36cc1cadfd106b6e5d74",
      measurementId: "G-RCJ4P82PVM"
    };

    const {
      initializeApp,
      getDatabase,
      ref,
      onValue,
      set,
      update,
    } = window.firebaseImports;

    // Init Firebase app and database
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    let nextId = 1000; // For new ids

    // EditableField component - for editing birthdays etc
    function EditableField({ label, value, type = "text", onChange }) {
      const [editing, setEditing] = useState(false);
      const [tempValue, setTempValue] = useState(value || "");

      function save() {
        onChange(tempValue);
        setEditing(false);
      }

      return (
        <div className="flex items-center space-x-1 text-sm text-gray-700">
          <span className="font-semibold">{label}:</span>
          {editing ? (
            type === "date" ? (
              <input
                type="date"
                value={tempValue}
                onChange={e => setTempValue(e.target.value)}
                onBlur={save}
                onKeyDown={e => { if (e.key === "Enter") save(); }}
                autoFocus
                className="border border-gray-300 rounded px-1 py-0.5 w-32"
              />
            ) : (
              <input
                type="text"
                value={tempValue}
                onChange={e => setTempValue(e.target.value)}
                onBlur={save}
                onKeyDown={e => { if (e.key === "Enter") save(); }}
                autoFocus
                className="border border-gray-300 rounded px-1 py-0.5 w-32"
              />
            )
          ) : (
            <span
              className="cursor-pointer hover:text-blue-600"
              onClick={() => setEditing(true)}
              title={`Click to edit ${label.toLowerCase()}`}
            >
              {value || <em className="text-gray-400">(none)</em>}
            </span>
          )}
        </div>
      );
    }

    function SpouseItem({ spouse, onUpdate, onDelete, highlight, blink }) {
      const [editName, setEditName] = useState(false);
      const [tempName, setTempName] = useState(spouse.name);
      const [showDates, setShowDates] = useState(false);

      function saveName() {
        onUpdate({ ...spouse, name: tempName });
        setEditName(false);
      }

      function updateField(field, val) {
        onUpdate({ ...spouse, [field]: val });
      }

      return (
        <div
          className={`flex items-center space-x-2 text-sm italic ${
            highlight ? "highlight" : ""
          } ${blink ? "blink-highlight" : ""} node-box`}
          style={{ minWidth: "0" }}
        >
          {editName ? (
            <input
              type="text"
              value={tempName}
              onChange={e => setTempName(e.target.value)}
              onBlur={saveName}
              onKeyDown={e => { if (e.key === "Enter") saveName(); }}
              autoFocus
              className="border border-gray-400 rounded px-1 py-0.5 w-full"
            />
          ) : (
            <span
              className="cursor-pointer hover:text-blue-600 flex-grow"
              onClick={() => setShowDates(!showDates)}
              title="Click to toggle spouse details"
              onDoubleClick={() => setEditName(true)}
            >
              {spouse.name || <em>(unnamed)</em>}
            </span>
          )}

          {showDates && (
            <>
              <EditableField
                label="Bday"
                type="date"
                value={spouse.birthday}
                onChange={val => updateField("birthday", val)}
              />
              <EditableField
                label="Dday"
                type="date"
                value={spouse.deathday}
                onChange={val => updateField("deathday", val)}
              />
              <button
                onClick={() => onDelete(spouse.id)}
                className="text-red-600 hover:text-red-800 font-bold select-none"
                title="Delete spouse"
              >
                ×
              </button>
            </>
          )}
        </div>
      );
    }

    function TreeNode({
      node,
      onUpdate,
      onDelete,
      highlightIds = new Set(),
      blinkId = null,
      openIds = new Set(),
      scrollToId = null,
      onScrollHandled,
    }) {
      const [open, setOpen] = useState(openIds.has(node.id));
      const [editName, setEditName] = useState(false);
      const [tempName, setTempName] = useState(node.name);
      const [showDetails, setShowDetails] = useState(false);
      const nodeRef = useRef(null);

      // Scroll into view if this is the searched node and not yet handled
      useEffect(() => {
        if (scrollToId === node.id && nodeRef.current && onScrollHandled) {
          nodeRef.current.scrollIntoView({ behavior: "smooth", block: "center" });
          onScrollHandled();
        }
      }, [scrollToId, node.id, onScrollHandled]);

      function saveName() {
        if (tempName.trim() === "") {
          alert("Name cannot be empty.");
          return;
        }
        onUpdate({ ...node, name: tempName });
        setEditName(false);
      }

      function updateField(field, val) {
        onUpdate({ ...node, [field]: val });
      }

      // Add spouse
      function addSpouse() {
        const newSpouse = {
          id: Date.now().toString(),
          name: "",
          birthday: "",
          deathday: "",
        };
        const newSpouses = node.spouses ? [...node.spouses, newSpouse] : [newSpouse];
        onUpdate({ ...node, spouses: newSpouses });
        setShowDetails(true);
      }

      // Update spouse
      function updateSpouse(updatedSpouse) {
        const newSpouses = node.spouses.map(s =>
          s.id === updatedSpouse.id ? updatedSpouse : s
        );
        onUpdate({ ...node, spouses: newSpouses });
      }

      // Delete spouse
      function deleteSpouse(spouseId) {
        const newSpouses = node.spouses.filter(s => s.id !== spouseId);
        onUpdate({ ...node, spouses: newSpouses });
      }

      // Add child
      function addChild() {
        const newChild = {
          id: Date.now().toString(),
          name: "",
          birthday: "",
          deathday: "",
          spouses: [],
          children: [],
        };
        const newChildren = node.children ? [...node.children, newChild] : [newChild];
        onUpdate({ ...node, children: newChildren });
        setOpen(true);
      }

      // Update child node
      function updateChild(updatedChild) {
        const newChildren = node.children.map(c =>
          c.id === updatedChild.id ? updatedChild : c
        );
        onUpdate({ ...node, children: newChildren });
      }

      // Delete child node
      function deleteChild(childId) {
        if (!confirm("Delete this child and all their descendants?")) return;
        const newChildren = node.children.filter(c => c.id !== childId);
        onUpdate({ ...node, children: newChildren });
      }

      return (
        <div className="mb-2" ref={nodeRef}>
          <div
            className={`node-box ${
              highlightIds.has(node.id) ? "highlight" : ""
            } ${blinkId === node.id ? "blink-highlight" : ""}`}
          >
            <div className="flex items-center space-x-2">
              {node.children && node.children.length > 0 && (
                <button
                  onClick={() => setOpen(!open)}
                  className="font-bold text-lg w-6 h-6 flex items-center justify-center select-none cursor-pointer"
                  title={open ? "Collapse children" : "Expand children"}
                >
                  {open ? "−" : "+"}
                </button>
              )}
              {!node.children || node.children.length === 0 && (
                <div className="w-6" />
              )}
              {editName ? (
                <input
                  type="text"
                  value={tempName}
                  onChange={e => setTempName(e.target.value)}
                  onBlur={saveName}
                  onKeyDown={e => { if (e.key === "Enter") saveName(); }}
                  autoFocus
                  className="border border-gray-400 rounded px-1 py-0.5 flex-grow"
                  placeholder="Name"
                />
              ) : (
                <span
                  className="cursor-pointer flex-grow"
                  onClick={() => setShowDetails(!showDetails)}
                  onDoubleClick={() => setEditName(true)}
                  title="Click to toggle details, double click to edit name"
                >
                  {node.name || <em className="text-gray-400">(unnamed)</em>}
                </span>
              )}
              <button
                className="text-red-600 hover:text-red-800 font-bold select-none"
                title="Delete this person and descendants"
                onClick={() => {
                  if (confirm("Delete this person and all descendants?")) {
                    onDelete(node.id);
                  }
                }}
              >
                ×
              </button>
            </div>
            {showDetails && (
              <div className="mt-1 space-y-1">
                <EditableField
                  label="Birthday"
                  type="date"
                  value={node.birthday}
                  onChange={val => updateField("birthday", val)}
                />
                <EditableField
                  label="Deathday"
                  type="date"
                  value={node.deathday}
                  onChange={val => updateField("deathday", val)}
                />
                <div>
                  <span className="font-semibold">Spouses:</span>
                  <div className="space-y-1 ml-2">
                    {(node.spouses || []).map(spouse => (
                      <SpouseItem
                        key={spouse.id}
                        spouse={spouse}
                        onUpdate={updateSpouse}
                        onDelete={deleteSpouse}
                        highlight={highlightIds.has(spouse.id)}
                        blink={blinkId === spouse.id}
                      />
                    ))}
                    <button
                      onClick={addSpouse}
                      className="text-blue-600 hover:text-blue-800 font-semibold text-sm select-none"
                      title="Add spouse"
                    >
                      + Add spouse
                    </button>
                  </div>
                </div>
                <button
                  onClick={addChild}
                  className="mt-1 text-green-600 hover:text-green-800 font-semibold text-sm select-none"
                  title="Add child"
                >
                  + Add child
                </button>
              </div>
            )}
          </div>

          {open && node.children && node.children.length > 0 && (
            <div className="tree-node-container ml-6 border-l-2 border-blue-400 pl-4">
              {node.children.map(child => (
                <TreeNode
                  key={child.id}
                  node={child}
                  onUpdate={updatedChild => updateChild(updatedChild)}
                  onDelete={deleteChild}
                  highlightIds={highlightIds}
                  blinkId={blinkId}
                  openIds={openIds}
                  scrollToId={scrollToId}
                  onScrollHandled={onScrollHandled}
                />
              ))}
            </div>
          )}
        </div>
      );
    }

    // Helper: Recursively update node by id
    function updateNodeById(tree, id, updater) {
      if (tree.id === id) {
        return updater(tree);
      }
      if (tree.children && tree.children.length > 0) {
        return {
          ...tree,
          children: tree.children.map(child => updateNodeById(child, id, updater))
        };
      }
      return tree;
    }

    // Helper: Recursively delete node by id
    function deleteNodeById(tree, id) {
      if (!tree.children || tree.children.length === 0) return tree;
      return {
        ...tree,
        children: tree.children
          .filter(child => child.id !== id)
          .map(child => deleteNodeById(child, id))
      };
    }

    // Helper: Collect all ids from node and descendants (for highlight)
    function collectAllIds(node, set) {
      set.add(node.id);
      if (node.spouses) {
        node.spouses.forEach(s => set.add(s.id));
      }
      if (node.children) {
        node.children.forEach(child => collectAllIds(child, set));
      }
    }

    // Helper: find node by id
    function findNodeById(node, id) {
      if (node.id === id) return node;
      if (node.children) {
        for (const child of node.children) {
          const found = findNodeById(child, id);
          if (found) return found;
        }
      }
      return null;
    }

    // Helper: get all ancestors of an id as set of ids
    function findAncestors(root, targetId) {
      let ancestors = new Set();

      function helper(node, path) {
        if (node.id === targetId) {
          path.forEach(id => ancestors.add(id));
          return true;
        }
        if (node.children) {
          for (const child of node.children) {
            if (helper(child, [...path, node.id])) {
              return true;
            }
          }
        }
        return false;
      }
      helper(root, []);
      return ancestors;
    }

    // Flatten node ids including spouses, children recursively
    function flattenNodeIds(node, set) {
      set.add(node.id);
      if (node.spouses) node.spouses.forEach(s => set.add(s.id));
      if (node.children) node.children.forEach(c => flattenNodeIds(c, set));
    }

    // Main App
    function App() {
      const [tree, setTree] = useState(null);
      const [loading, setLoading] = useState(true);
      const [searchText, setSearchText] = useState("");
      const [searchId, setSearchId] = useState(null);
      const [highlightIds, setHighlightIds] = useState(new Set());
      const [blinkId, setBlinkId] = useState(null);
      const [openIds, setOpenIds] = useState(new Set());
      const [scrollHandled, setScrollHandled] = useState(false);

      // Load data from Firebase on mount
      useEffect(() => {
        const treeRef = ref(database, "familyTree");
        const unsubscribe = onValue(treeRef, snapshot => {
          if (snapshot.exists()) {
            setTree(snapshot.val());
          } else {
            // Initialize with sample tree if empty
            const initialTree = {
              id: "root",
              name: "John Smith",
              birthday: "1950-01-01",
              deathday: "",
              spouses: [
                { id: "s1", name: "Jane Doe", birthday: "1952-05-10", deathday: "" }
              ],
              children: [
                {
                  id: "c1",
                  name: "Alice Smith",
                  birthday: "1975-08-15",
                  deathday: "",
                  spouses: [
                    { id: "s2", name: "Bob Johnson", birthday: "1970-04-22", deathday: "" }
                  ],
                  children: []
                }
              ]
            };
            set(tree => initialTree);
            set(ref(database, "familyTree"), initialTree);
          }
          setLoading(false);
        });
        return () => unsubscribe();
      }, []);

      // Save tree to Firebase on changes
      useEffect(() => {
        if (!loading && tree) {
          set(ref(database, "familyTree"), tree);
        }
      }, [tree, loading]);

      // Update node handler
      function onUpdateNode(updatedNode) {
        setTree(tree => updateNodeById(tree, updatedNode.id, () => updatedNode));
      }

      // Delete node handler
      function onDeleteNode(nodeId) {
        if (tree.id === nodeId) {
          alert("Cannot delete root node.");
          return;
        }
        setTree(tree => deleteNodeById(tree, nodeId));
      }

      // Search handler - finds first node with name or spouse name matching searchText
      function handleSearch() {
        if (!searchText.trim()) {
          setHighlightIds(new Set());
          setBlinkId(null);
          setSearchId(null);
          setOpenIds(new Set());
          setScrollHandled(false);
          return;
        }
        // Breadth-first search to find node or spouse matching searchText (case insensitive)
        let queue = [tree];
        let foundNode = null;
        while (queue.length > 0) {
          let current = queue.shift();
          if (
            current.name.toLowerCase().includes(searchText.toLowerCase())
          ) {
            foundNode = current;
            break;
          }
          if (current.spouses && current.spouses.some(s => s.name.toLowerCase().includes(searchText.toLowerCase()))) {
            foundNode = current;
            break;
          }
          if (current.children) {
            queue.push(...current.children);
          }
        }
        if (foundNode) {
          setSearchId(foundNode.id);
          // Highlight ancestors + node + spouses
          const ancestors = findAncestors(tree, foundNode.id);
          const idsToHighlight = new Set(ancestors);
          flattenNodeIds(foundNode, idsToHighlight);
          setHighlightIds(idsToHighlight);
          setBlinkId(foundNode.id);
          setOpenIds(ancestors);
          setScrollHandled(false);
        } else {
          alert("No match found.");
          setHighlightIds(new Set());
          setBlinkId(null);
          setSearchId(null);
          setOpenIds(new Set());
          setScrollHandled(false);
        }
      }

      // Expand all nodes button
      function expandAll() {
        function collectIds(node, set) {
          set.add(node.id);
          if (node.children) node.children.forEach(c => collectIds(c, set));
        }
        const allIds = new Set();
        collectIds(tree, allIds);
        setOpenIds(allIds);
      }

      // Collapse all nodes button
      function collapseAll() {
        setOpenIds(new Set());
      }

      return (
        <>
          <h1 className="text-2xl font-bold mb-4 text-center text-blue-700">Family Tree with Firebase</h1>
          <div className="flex flex-col sm:flex-row sm:items-center sm:space-x-2 mb-4 max-w-xl mx-auto">
            <input
              type="search"
              placeholder="Search by name (person or spouse)"
              className="flex-grow border border-gray-300 rounded px-3 py-2 mb-2 sm:mb-0"
              value={searchText}
              onChange={e => setSearchText(e.target.value)}
              onKeyDown={e => { if (e.key === "Enter") handleSearch(); }}
              aria-label="Search family tree"
            />
            <button
              onClick={handleSearch}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
              aria-label="Search button"
            >
              Search
            </button>
          </div>
          <div className="flex justify-center space-x-4 mb-4">
            <button
              onClick={expandAll}
              className="toggle-expand-btn"
              aria-label="Expand all nodes"
            >
              Expand All
            </button>
            <button
              onClick={collapseAll}
              className="toggle-expand-btn"
              aria-label="Collapse all nodes"
            >
              Collapse All
            </button>
          </div>

          <div
            id="tree-scroll-container"
            role="region"
            aria-label="Family tree scrollable container"
          >
            {loading && <p>Loading family tree...</p>}
            {!loading && tree && (
              <TreeNode
                node={tree}
                onUpdate={onUpdateNode}
                onDelete={onDeleteNode}
                highlightIds={highlightIds}
                blinkId={blinkId}
                openIds={openIds}
                scrollToId={searchId}
                onScrollHandled={() => setScrollHandled(true)}
              />
            )}
          </div>
        </>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
