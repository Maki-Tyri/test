import React, { useState, useEffect, useRef } from "react";

const blinkAnimation = `
@keyframes blink {
  0%, 100% { background-color: transparent; }
  50% { background-color: #fef3c7; } /* yellow highlight */
}
.blink-highlight {
  animation: blink 1.5s infinite;
}
`;

function EditableField({ label, value, onChange, type = "text" }) {
  return (
    <label className="ml-2 text-sm text-gray-600 flex items-center space-x-1">
      <span>{label}:</span>
      <input
        type={type}
        value={value || ""}
        onChange={e => onChange(e.target.value)}
        className="border border-gray-300 rounded px-1 py-0.5 w-24"
      />
    </label>
  );
}

function SpouseItem({ spouse, onUpdate, onDelete, highlight }) {
  const [editName, setEditName] = useState(false);
  const [tempName, setTempName] = useState(spouse.name);

  useEffect(() => setTempName(spouse.name), [spouse.name]);

  function saveName() {
    onUpdate({ ...spouse, name: tempName });
    setEditName(false);
  }

  return (
    <div className={`border rounded px-2 py-1 flex items-center space-x-2 ${highlight ? "blink-highlight" : ""}`}>
      {editName ? (
        <input
          type="text"
          value={tempName}
          onChange={e => setTempName(e.target.value)}
          onBlur={saveName}
          onKeyDown={e => { if (e.key === "Enter") saveName(); }}
          autoFocus
          className="border border-gray-400 rounded px-1 py-0.5 w-32"
        />
      ) : (
        <span
          onDoubleClick={() => setEditName(true)}
          className="cursor-pointer font-semibold"
          title="Double-click to edit"
        >
          {spouse.name || <em>(unnamed)</em>}
        </span>
      )}

      <EditableField label="Bday" type="date" value={spouse.birthday} onChange={v => onUpdate({ ...spouse, birthday: v })} />
      <EditableField label="Dday" type="date" value={spouse.deathday} onChange={v => onUpdate({ ...spouse, deathday: v })} />
      <button
        onClick={() => onDelete(spouse.id)}
        className="text-red-600 hover:text-red-800 font-bold select-none"
        title="Delete Spouse"
      >
        ×
      </button>
    </div>
  );
}

// Recursive TreeNode with boxes and vertical/horizontal connecting lines
function TreeNode({ node, onUpdate, onDelete, highlightIds, openIds, scrollToId, onScrollHandled }) {
  const [open, setOpen] = useState(openIds.has(node.id));
  const ref = useRef();

  useEffect(() => {
    setOpen(openIds.has(node.id));
  }, [openIds, node.id]);

  useEffect(() => {
    if (scrollToId === node.id && ref.current) {
      ref.current.scrollIntoView({ behavior: "smooth", block: "center" });
      onScrollHandled();
    }
  }, [scrollToId, node.id, onScrollHandled]);

  // Update node helper
  function updateNode(updatedNode) {
    if (updatedNode.id === node.id) {
      onUpdate(updatedNode);
    } else if (node.children) {
      const newChildren = node.children.map(c => {
        if (c.id === updatedNode.id) return updatedNode;
        return c;
      });
      onUpdate({ ...node, children: newChildren });
    }
  }

  // Add child
  function addChild() {
    const newChild = {
      id: Date.now(),
      name: "New Child",
      birthday: "",
      deathday: "",
      spouses: [],
      children: [],
    };
    const children = node.children ? [...node.children, newChild] : [newChild];
    onUpdate({ ...node, children });
    setOpen(true);
  }

  // Delete child
  function deleteChild(id) {
    if (!node.children) return;
    onUpdate({ ...node, children: node.children.filter(c => c.id !== id) });
  }

  // Update child node
  function updateChild(childNode) {
    if (!node.children) return;
    const newChildren = node.children.map(c => (c.id === childNode.id ? childNode : c));
    onUpdate({ ...node, children: newChildren });
  }

  // Add spouse
  function addSpouse() {
    if (node.spouses && node.spouses.length >= 2) {
      alert("Only up to 2 spouses allowed.");
      return;
    }
    const newSpouse = {
      id: Date.now() + Math.random(),
      name: "New Spouse",
      birthday: "",
      deathday: "",
    };
    const spouses = node.spouses ? [...node.spouses, newSpouse] : [newSpouse];
    onUpdate({ ...node, spouses });
  }

  // Update spouse
  function updateSpouse(updatedSpouse) {
    const newSpouses = (node.spouses || []).map(s => (s.id === updatedSpouse.id ? updatedSpouse : s));
    onUpdate({ ...node, spouses: newSpouses });
  }

  // Delete spouse
  function deleteSpouse(id) {
    const newSpouses = (node.spouses || []).filter(s => s.id !== id);
    onUpdate({ ...node, spouses: newSpouses });
  }

  const isHighlighted = highlightIds.has(node.id);

  // Handle name editing
  const [editName, setEditName] = useState(false);
  const [tempName, setTempName] = useState(node.name);

  useEffect(() => setTempName(node.name), [node.name]);

  function saveName() {
    onUpdate({ ...node, name: tempName });
    setEditName(false);
  }

  // Toggle dates display
  const [showDates, setShowDates] = useState(false);

  // Styling boxes with connecting lines (vertical and horizontal)
  return (
    <div ref={ref} className="relative ml-4 mt-2">
      <style>{blinkAnimation}</style>

      {/* Box with border and blinking highlight if selected */}
      <div
        className={`border rounded-md p-3 bg-white shadow-sm cursor-default select-none
          ${isHighlighted ? "blink-highlight border-yellow-400" : "border-gray-300"}
        `}
        onClick={() => setShowDates(!showDates)}
        onDoubleClick={() => setEditName(true)}
        title="Click to toggle dates, double-click to edit name"
      >
        {editName ? (
          <input
            type="text"
            value={tempName}
            onChange={e => setTempName(e.target.value)}
            onBlur={saveName}
            onKeyDown={e => e.key === "Enter" && saveName()}
            autoFocus
            className="border border-gray-400 rounded px-1 py-0.5 w-48"
          />
        ) : (
          <div className="font-semibold">{node.name || <em>(unnamed)</em>}</div>
        )}

        {showDates && (
          <div className="flex space-x-2 mt-1 text-xs text-gray-600">
            <EditableField
              label="Bday"
              type="date"
              value={node.birthday}
              onChange={v => onUpdate({ ...node, birthday: v })}
            />
            <EditableField
              label="Dday"
              type="date"
              value={node.deathday}
              onChange={v => onUpdate({ ...node, deathday: v })}
            />
          </div>
        )}

        <div className="flex space-x-2 mt-2">
          <button
            onClick={addChild}
            className="text-green-600 hover:text-green-800 font-bold select-none"
            title="Add Child"
            type="button"
          >
            + Child
          </button>
          <button
            onClick={addSpouse}
            className="text-purple-600 hover:text-purple-800 font-bold select-none"
            title="Add Spouse"
            type="button"
          >
            ♥ Spouse
          </button>
          {node.id !== 1 && (
            <button
              onClick={() => onDelete(node.id)}
              className="text-red-600 hover:text-red-800 font-bold select-none"
              title="Delete Person"
              type="button"
            >
              × Delete
            </button>
          )}
        </div>

        {/* Spouses */}
        {node.spouses && node.spouses.length > 0 && (
          <div className="mt-3 space-y-1">
            {node.spouses.map(spouse => (
              <SpouseItem
                key={spouse.id}
                spouse={spouse}
                onUpdate={updateSpouse}
                onDelete={deleteSpouse}
                highlight={highlightIds.has(spouse.id)}
              />
            ))}
          </div>
        )}
      </div>

      {/* Vertical connecting line down to children */}
      {node.children && node.children.length > 0 && open && (
        <div className="ml-8 mt-1 border-l-2 border-gray-300 pl-4">
          {/* Horizontal line connecting siblings */}
          <div className="flex space-x-4 border-b-2 border-gray-300 pb-2">
            {node.children.map(child => (
              <div key={child.id} className="relative">
                {/* Small vertical line from horizontal line to child box */}
                <div className="absolute -top-2 left-1/2 w-0.5 h-2 bg-gray-300" />
                <TreeNode
                  node={child}
                  onUpdate={updateChild}
                  onDelete={deleteChild}
                  highlightIds={highlightIds}
                  openIds={openIds}
                  scrollToId={scrollToId}
                  onScrollHandled={onScrollHandled}
                />
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Toggle children visibility */}
      {node.children && node.children.length > 0 && (
        <button
          onClick={() => setOpen(!open)}
          className="mt-1 text-xs text-gray-500 hover:text-gray-700"
          type="button"
        >
          {open ? "Collapse children" : "Expand children"}
        </button>
      )}
    </div>
  );
}

// Login form component
function LoginForm({ onLogin }) {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");

  function handleSubmit(e) {
    e.preventDefault();
    // Simple hardcoded auth for demo (replace with real auth)
    if (username === "admin" && password === "password") {
      onLogin(true);
    } else {
      alert("Invalid credentials! Try admin / password");
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <form
        onSubmit={handleSubmit}
        className="bg-white p-8 rounded shadow-md w-80"
      >
        <h2 className="text-2xl font-bold mb-6 text-center">Login</h2>
        <input
          type="text"
          placeholder="Username"
          value={username}
          onChange={e => setUsername(e.target.value)}
          className="w-full mb-4 border border-gray-300 rounded px-3 py-2"
          autoFocus
          required
        />
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={e => setPassword(e.target.value)}
          className="w-full mb-6 border border-gray-300 rounded px-3 py-2"
          required
        />
        <button
          type="submit"
          className="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 rounded font-semibold"
        >
          Log In
        </button>
      </form>
    </div>
  );
}

function FamilyTreeApp() {
  const [family, setFamily] = useState(null);
  const [loggedIn, setLoggedIn] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [highlightIds, setHighlightIds] = useState(new Set());
  const [openIds, setOpenIds] = useState(new Set());
  const [scrollToId, setScrollToId] = useState(null);

  // Load initial dummy family data for demo
  useEffect(() => {
    if (!family) {
      const root = {
        id: 1,
        name: "Root Ancestor",
        birthday: "1940-01-01",
        deathday: "",
        spouses: [{ id: 10, name: "Root Spouse", birthday: "1945-02-02", deathday: "" }],
        children: [
          {
            id: 2,
            name: "Child One",
            birthday: "1970-03-03",
            deathday: "",
            spouses: [{ id: 11, name: "Spouse One", birthday: "", deathday: "" }],
            children: [],
          },
          {
            id: 3,
            name: "Child Two",
            birthday: "1972-04-04",
            deathday: "",
            spouses: [],
            children: [],
          },
        ],
      };
      setFamily(root);
    }
  }, [family]);

  // Search tree function recursive
  function searchTree(node, term, results = []) {
    if (!node) return results;
    if (node.name && node.name.toLowerCase().includes(term.toLowerCase())) results.push(node);
    if (node.spouses) {
      node.spouses.forEach(s => {
        if (s.name && s.name.toLowerCase().includes(term.toLowerCase())) {
          results.push({ ...s, isSpouse: true });
        }
      });
    }
    if (node.children) {
      node.children.forEach(c => searchTree(c, term, results));
    }
    return results;
  }

  // Get all ancestors for highlighting and opening
  function getAncestorsIds(id, node, ancestors = []) {
    if (!node.children) return ancestors;
    for (const c of node.children) {
      if (c.id === id) {
        ancestors.push(node.id);
        return ancestors;
      }
      const found = getAncestorsIds(id, c, ancestors);
      if (found.length) {
        ancestors.push(node.id);
        return ancestors;
      }
    }
    return ancestors;
  }

  // On selecting search result: highlight + open ancestors + scroll + blink
  function onSelectSearchResult(person) {
    setSearchResults([]);
    setSearchTerm(person.name);

    let newHighlightIds = new Set();
    newHighlightIds.add(person.id);

    // If person is spouse, find parent node (complex)
    if (person.isSpouse) {
      // Find parent of this spouse
      function findParentOfSpouse(node) {
        if (!node.spouses) return null;
        if (node.spouses.some(s => s.id === person.id)) return node;
        if (!node.children) return null;
        for (const c of node.children) {
          const res = findParentOfSpouse(c);
          if (res) return res;
        }
        return null;
      }
      const parentNode = findParentOfSpouse(family);
      if (parentNode) {
        newHighlightIds.add(parentNode.id);
      }
    } else {
      // Add ancestors of person (parents, grandparents)
      const ancestors = getAncestorsIds(person.id, family);
      ancestors.forEach(id => newHighlightIds.add(id));
    }

    setHighlightIds(newHighlightIds);

    // Expand ancestors so they are visible
    setOpenIds(newHighlightIds);

    // Scroll to highlighted person
    setScrollToId(person.id);
  }

  function onScrollHandled() {
    setScrollToId(null);
  }

  // Update family data tree (deep update)
  function updateNode(updatedNode, currentNode = family) {
    if (updatedNode.id === currentNode.id) {
      setFamily(updatedNode);
      return;
    }
    if (!currentNode.children) return;
    const newChildren = currentNode.children.map(c => {
      if (c.id === updatedNode.id) return updatedNode;
      else {
        updateNode(updatedNode, c);
        return c;
      }
    });
    setFamily({ ...currentNode, children: newChildren });
  }

  function deleteNode(id, currentNode = family) {
    if (!currentNode.children) return currentNode;
    const filtered = currentNode.children.filter(c => c.id !== id);
    if (filtered.length !== currentNode.children.length) {
      return { ...currentNode, children: filtered };
    }
    const newChildren = currentNode.children.map(c => deleteNode(id, c));
    return { ...currentNode, children: newChildren };
  }

  // Delete helper
  function handleDelete(id) {
    const newFamily = deleteNode(id, family);
    setFamily(newFamily);
  }

  // Handle search input change
  function onSearchChange(e) {
    const val = e.target.value;
    setSearchTerm(val);
    if (val.trim().length === 0) {
      setSearchResults([]);
      setHighlightIds(new Set());
      setOpenIds(new Set());
      return;
    }
    if (family) {
      const results = searchTree(family, val);
      setSearchResults(results);
    }
  }

  if (!loggedIn) {
    return <LoginForm onLogin={setLoggedIn} />;
  }

  if (!family) return <div>Loading...</div>;

  return (
    <div className="min-h-screen bg-gray-100 p-6">
      <style>{blinkAnimation}</style>

      <header className="mb-6 flex justify-between items-center">
        <input
          type="search"
          placeholder="Search name..."
          value={searchTerm}
          onChange={onSearchChange}
          className="px-4 py-2 rounded border border-gray-300 w-80"
          autoComplete="off"
        />
        <button
          onClick={() => setLoggedIn(false)}
          className="bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700"
        >
          Logout
        </button>
      </header>

      {/* Search results dropdown */}
      {searchResults.length > 0 && (
        <ul className="max-h-48 overflow-auto border border-gray-300 bg-white rounded shadow-md w-80 mb-4">
          {searchResults.map(r => (
            <li
              key={r.id}
              className="px-3 py-2 cursor-pointer hover:bg-yellow-100"
              onClick={() => onSelectSearchResult(r)}
            >
              {r.name} {r.isSpouse ? "(Spouse)" : ""}
            </li>
          ))}
        </ul>
      )}

      {/* Family tree */}
      <div className="overflow-auto max-w-full max-h-[70vh] bg-white rounded shadow p-4">
        <TreeNode
          node={family}
          onUpdate={updateNode}
          onDelete={handleDelete}
          highlightIds={highlightIds}
          openIds={openIds}
          scrollToId={scrollToId}
          onScrollHandled={onScrollHandled}
        />
      </div>
    </div>
  );
}

export default FamilyTreeApp;
