<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Family Tree Search with Ancestor Blink</title>
  <style>
    /* Tailwind's base styles are assumed */

    .node-box {
      border: 2px solid #3b82f6; /* blue-500 */
      padding: 6px 10px;
      margin-bottom: 4px;
      border-radius: 6px;
      display: inline-block;
      min-width: fit-content;
      max-width: 250px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      user-select: none;
    }

    .node-box.highlight {
      background-color: #fef3c7; /* yellow-100 */
      border-color: #ca8a04; /* yellow-700 */
    }

    .blink-highlight {
      animation: blink 1s ease-in-out infinite alternate;
    }

    @keyframes blink {
      0%, 100% {
        background-color: #fef3c7; /* yellow-100 */
        border-color: #ca8a04; /* yellow-700 */
      }
      50% {
        background-color: #facc15; /* yellow-400 */
        border-color: #854d0e; /* darker yellow */
      }
    }

    .tree-node-container {
      margin-left: 20px;
      border-left: 2px solid #3b82f6;
      padding-left: 8px;
    }

    .spouse-box {
      border: 2px solid #10b981; /* green-500 */
      padding: 4px 8px;
      margin-bottom: 3px;
      border-radius: 6px;
      display: inline-block;
      min-width: fit-content;
      max-width: 250px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      user-select: none;
    }

    .highlight-spouse {
      background-color: #bbf7d0; /* green-100 */
      border-color: #059669; /* green-600 */
    }

    .blink-highlight-spouse {
      animation: blink 1s ease-in-out infinite alternate;
    }

    input[type="text"], input[type="date"] {
      font-size: 0.85rem;
      padding: 3px 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    button {
      cursor: pointer;
    }

    .toggle-expand-btn {
      margin-bottom: 10px;
      padding: 6px 12px;
      border-radius: 6px;
      background-color: #3b82f6;
      color: white;
      border: none;
      font-weight: 600;
    }

    .toggle-expand-btn:hover {
      background-color: #2563eb;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
    const { useState, useEffect, useRef } = React;

    // Firebase initialization (replace with your config)
    const firebaseConfig = {
      apiKey: "YOUR_API_KEY",
      authDomain: "YOUR_AUTH_DOMAIN",
      databaseURL: "YOUR_DB_URL",
      projectId: "YOUR_PROJECT_ID",
      storageBucket: "YOUR_STORAGE_BUCKET",
      messagingSenderId: "YOUR_SENDER_ID",
      appId: "YOUR_APP_ID"
    };

    const app = firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    let nextId = 1000; // For new nodes/spouses

    function EditableField({ label, type, value, onChange }) {
      return (
        <label style={{ marginRight: 8, fontSize: 12, color: "#555" }}>
          {label}:
          <input
            type={type}
            value={value || ""}
            onChange={e => onChange(e.target.value)}
            style={{ marginLeft: 4 }}
          />
        </label>
      );
    }

    function SpouseItem({ spouse, onUpdate, onDelete, highlight, blink }) {
      const [editName, setEditName] = useState(false);
      const [tempName, setTempName] = useState(spouse.name || "");

      useEffect(() => {
        setTempName(spouse.name || "");
      }, [spouse.name]);

      function saveName() {
        onUpdate({ ...spouse, name: tempName });
        setEditName(false);
      }

      return (
        <div
          className={`spouse-box ${
            highlight ? "highlight-spouse" : ""
          } ${blink ? "blink-highlight-spouse" : ""}`}
          title="Spouse"
        >
          {editName ? (
            <input
              type="text"
              value={tempName}
              onChange={e => setTempName(e.target.value)}
              onBlur={saveName}
              onKeyDown={e => { if (e.key === "Enter") saveName(); }}
              autoFocus
              style={{ width: "auto", minWidth: "50px" }}
            />
          ) : (
            <span onDoubleClick={() => setEditName(true)}>
              {spouse.name || <em style={{ color: "#888" }}>(unnamed)</em>}
            </span>
          )}
          <div style={{ marginTop: 4, fontSize: 10, color: "#666" }}>
            <EditableField
              label="Bday"
              type="date"
              value={spouse.birthday}
              onChange={val => onUpdate({ ...spouse, birthday: val })}
            />
            <EditableField
              label="Dday"
              type="date"
              value={spouse.deathday}
              onChange={val => onUpdate({ ...spouse, deathday: val })}
            />
            <button
              onClick={e => { e.stopPropagation(); onDelete(spouse.id); }}
              style={{ marginLeft: 10, color: "red", fontWeight: "bold" }}
              title="Delete spouse"
            >
              ×
            </button>
          </div>
        </div>
      );
    }

    function TreeNode({
      node,
      onUpdate,
      onDelete,
      highlightIds,
      blinkIds,
      openIds,
      scrollToId,
      onScrollHandled,
    }) {
      const [open, setOpen] = useState(openIds.has(node.id));
      const [editName, setEditName] = useState(false);
      const [tempName, setTempName] = useState(node.name || "");
      const ref = useRef(null);

      useEffect(() => {
        setOpen(openIds.has(node.id));
      }, [openIds, node.id]);

      useEffect(() => {
        setTempName(node.name || "");
      }, [node.name]);

      useEffect(() => {
        if (scrollToId === node.id && ref.current) {
          ref.current.scrollIntoView({ behavior: "smooth", block: "center", inline: "center" });
          onScrollHandled();
        }
      }, [scrollToId, node.id, onScrollHandled]);

      function saveName() {
        onUpdate({ ...node, name: tempName });
        setEditName(false);
      }

      function updateField(field, val) {
        onUpdate({ ...node, [field]: val });
      }

      function addChild() {
        const newChild = {
          id: nextId++,
          name: "",
          birthday: "",
          deathday: "",
          spouses: [],
          children: [],
        };
        const updated = {
          ...node,
          children: [...(node.children || []), newChild],
        };
        onUpdate(updated);
        setOpen(true);
      }

      function addSpouse() {
        const newSpouse = {
          id: nextId++,
          name: "",
          birthday: "",
          deathday: "",
        };
        const updated = {
          ...node,
          spouses: [...(node.spouses || []), newSpouse],
        };
        onUpdate(updated);
      }

      function updateChild(updatedChild) {
        const updated = {
          ...node,
          children: (node.children || []).map(c => (c.id === updatedChild.id ? updatedChild : c)),
        };
        onUpdate(updated);
      }

      function deleteChild(childId) {
        const updated = {
          ...node,
          children: (node.children || []).filter(c => c.id !== childId),
        };
        onUpdate(updated);
      }

      function updateSpouse(updatedSpouse) {
        const updated = {
          ...node,
          spouses: (node.spouses || []).map(s => (s.id === updatedSpouse.id ? updatedSpouse : s)),
        };
        onUpdate(updated);
      }

      function deleteSpouse(spouseId) {
        const updated = {
          ...node,
          spouses: (node.spouses || []).filter(s => s.id !== spouseId),
        };
        onUpdate(updated);
      }

      const isHighlighted = highlightIds.has(node.id);
      const isBlinking = blinkIds.has(node.id);

      return (
        <div ref={ref} style={{ marginBottom: 6 }}>
          <div
            className={`node-box ${isHighlighted ? "highlight" : ""} ${
              isBlinking ? "blink-highlight" : ""
            }`}
            onClick={() => setOpen(!open)}
            title="Click to expand/collapse"
            style={{ minWidth: "fit-content", maxWidth: 250 }}
          >
            {editName ? (
              <input
                type="text"
                value={tempName}
                onChange={e => setTempName(e.target.value)}
                onBlur={saveName}
                onKeyDown={e => { if (e.key === "Enter") saveName(); }}
                autoFocus
                style={{ width: "auto", minWidth: "50px" }}
              />
            ) : (
              <span onDoubleClick={() => setEditName(true)}>{node.name || <em style={{ color: "#888" }}>(unnamed)</em>}</span>
            )}
            <div style={{ marginTop: 4, fontSize: 10, color: "#666", display: "flex", flexWrap: "wrap", gap: "6px" }}>
              <EditableField
                label="Bday"
                type="date"
                value={node.birthday}
                onChange={val => updateField("birthday", val)}
              />
              <EditableField
                label="Dday"
                type="date"
                value={node.deathday}
                onChange={val => updateField("deathday", val)}
              />
              <button
                onClick={e => { e.stopPropagation(); onDelete(node.id); }}
                style={{ marginLeft: "auto", color: "red", fontWeight: "bold" }}
                title="Delete node"
              >
                ×
              </button>
            </div>
            <div style={{ marginTop: 6 }}>
              <button
                onClick={e => { e.stopPropagation(); addChild(); }}
                style={{ marginRight: 12, fontSize: 12, color: "#3b82f6", fontWeight: "600", background: "none", border: "none", cursor: "pointer" }}
                title="Add child"
              >
                + Child
              </button>
              <button
                onClick={e => { e.stopPropagation(); addSpouse(); }}
                style={{ fontSize: 12, color: "#10b981", fontWeight: "600", background: "none", border: "none", cursor: "pointer" }}
                title="Add spouse"
              >
                + Spouse
              </button>
            </div>
          </div>

          {/* Spouses */}
          {open && node.spouses && node.spouses.length > 0 && (
            <div style={{ paddingLeft: 24, marginTop: 4, display: "flex", flexDirection: "column", gap: 4 }}>
              {node.spouses.map(spouse => (
                <SpouseItem
                  key={spouse.id}
                  spouse={spouse}
                  onUpdate={updateSpouse}
                  onDelete={deleteSpouse}
                  highlight={highlightIds.has(spouse.id)}
                  blink={blinkIds.has(spouse.id)}
                />
              ))}
            </div>
          )}

          {/* Children */}
          {open && node.children && node.children.length > 0 && (
            <div className="tree-node-container" style={{ marginTop: 8 }}>
              {node.children.map(child => (
                <TreeNode
                  key={child.id}
                  node={child}
                  onUpdate={updateChild}
                  onDelete={deleteChild}
                  highlightIds={highlightIds}
                  blinkIds={blinkIds}
                  openIds={openIds}
                  scrollToId={scrollToId}
                  onScrollHandled={onScrollHandled}
                />
              ))}
            </div>
          )}
        </div>
      );
    }

    function FamilyTreeApp() {
      const [treeData, setTreeData] = useState(null);
      const [search, setSearch] = useState("");
      const [highlightIds, setHighlightIds] = useState(new Set());
      const [blinkIds, setBlinkIds] = useState(new Set());
      const [openIds, setOpenIds] = useState(new Set());
      const [scrollToId, setScrollToId] = useState(null);
      const [expandAll, setExpandAll] = useState(true);

      // Load data from Firebase on mount
      useEffect(() => {
        const dbRef = firebase.database().ref("/tree");
        dbRef.on("value", (snapshot) => {
          const val = snapshot.val();
          if (val) {
            setTreeData(val);
          } else {
            // If no data, initialize an example root node
            const rootNode = {
              id: 1,
              name: "Root Person",
              birthday: "1970-01-01",
              deathday: "",
              spouses: [],
              children: [],
            };
            setTreeData(rootNode);
            firebase.database().ref("/tree").set(rootNode);
          }
        });
        return () => dbRef.off();
      }, []);

      // Save data to Firebase when treeData changes (debounced)
      useEffect(() => {
        if (!treeData) return;
        const timeout = setTimeout(() => {
          firebase.database().ref("/tree").set(treeData);
        }, 300);
        return () => clearTimeout(timeout);
      }, [treeData]);

      // Flatten tree to array with references for searching and expanding
      function flattenTree(node) {
        let arr = [node];
        (node.children || []).forEach(child => {
          arr = arr.concat(flattenTree(child));
        });
        (node.spouses || []).forEach(spouse => {
          arr.push(spouse);
        });
        return arr;
      }

      // Find ancestors of a node by ID, returns Set of IDs including ancestors and the node itself
      function findAncestors(targetId, root, ancestors = new Set()) {
        if (root.id === targetId) {
          ancestors.add(root.id);
          return true;
        }
        let found = false;
        (root.children || []).forEach(child => {
          if (findAncestors(targetId, child, ancestors)) {
            ancestors.add(root.id);
            found = true;
          }
        });
        return found;
      }

      // Search and update highlights + open states + blinking including ancestors
      useEffect(() => {
        if (!treeData) return;

        if (!search.trim()) {
          // Clear highlights and open all if expandAll true, else close all
          setHighlightIds(new Set());
          setBlinkIds(new Set());
          setOpenIds(expandAll ? collectAllNodeIds(treeData) : new Set());
          return;
        }

        const allNodes = flattenTree(treeData);
        const lowerSearch = search.trim().toLowerCase();

        // Find all nodes/spouses whose name includes search
        const matchedNodes = allNodes.filter(n => n.name?.toLowerCase().includes(lowerSearch));

        if (matchedNodes.length === 0) {
          setHighlightIds(new Set());
          setBlinkIds(new Set());
          setOpenIds(new Set());
          return;
        }

        // IDs to highlight (all matched)
        const highlightSet = new Set(matchedNodes.map(n => n.id));

        // Collect IDs of all matched nodes + their ancestors (for blinking)
        const blinkSet = new Set();
        matchedNodes.forEach(node => {
          blinkSet.add(node.id);
          findAncestors(node.id, treeData, blinkSet);
        });

        // Collect open node IDs to show matched and ancestors
        const openSet = new Set();
        matchedNodes.forEach(node => findAncestors(node.id, treeData, openSet));

        setHighlightIds(highlightSet);
        setBlinkIds(blinkSet);
        setOpenIds(openSet);

        // Scroll to first matched node after short delay
        setTimeout(() => {
          setScrollToId(matchedNodes[0].id);
        }, 400);

      }, [search, treeData, expandAll]);

      // Clear scrollToId once handled
      function onScrollHandled() {
        setScrollToId(null);
      }

      // Update a node anywhere in tree by id recursively
      function updateNodeById(currentNode, updatedNode) {
        if (currentNode.id === updatedNode.id) return updatedNode;
        return {
          ...currentNode,
          children: (currentNode.children || []).map(child => updateNodeById(child, updatedNode)),
        };
      }

      // Delete node by id recursively
      function deleteNodeById(currentNode, idToDelete) {
        return {
          ...currentNode,
          children: (currentNode.children || [])
            .filter(child => child.id !== idToDelete)
            .map(child => deleteNodeById(child, idToDelete)),
        };
      }

      function handleUpdate(updatedNode) {
        setTreeData(prev => updateNodeById(prev, updatedNode));
      }

      function handleDelete(id) {
        if (!treeData) return;
        if (treeData.id === id) {
          alert("Cannot delete root node");
          return;
        }
        setTreeData(prev => deleteNodeById(prev, id));
      }

      // Helper: collect all node ids for expandAll default
      function collectAllNodeIds(node) {
        let s = new Set([node.id]);
        (node.children || []).forEach(child => {
          collectAllNodeIds(child).forEach(id => s.add(id));
        });
        return s;
      }

      function toggleExpandAll() {
        if (!treeData) return;
        if (expandAll) {
          setOpenIds(new Set());
        } else {
          setOpenIds(collectAllNodeIds(treeData));
        }
        setExpandAll(!expandAll);
      }

      return (
        <div style={{ maxWidth: 900, margin: "auto", padding: 20, fontFamily: "Arial, sans-serif" }}>
          <h1 style={{ textAlign: "center" }}>Family Tree Search</h1>

          <div style={{ marginBottom: 12, textAlign: "center" }}>
            <input
              type="text"
              placeholder="Search names..."
              value={search}
              onChange={e => setSearch(e.target.value)}
              style={{
                width: "60%",
                padding: 8,
                fontSize: 16,
                borderRadius: 6,
                border: "2px solid #3b82f6",
                outline: "none",
              }}
            />
          </div>

          <div style={{ marginBottom: 12, textAlign: "center" }}>
            <button className="toggle-expand-btn" onClick={toggleExpandAll}>
              {expandAll ? "Collapse All" : "Expand All"}
            </button>
          </div>

          <div>
            {treeData ? (
              <TreeNode
                node={treeData}
                onUpdate={handleUpdate}
                onDelete={handleDelete}
                highlightIds={highlightIds}
                blinkIds={blinkIds}
                openIds={openIds}
                scrollToId={scrollToId}
                onScrollHandled={onScrollHandled}
              />
            ) : (
              <p>Loading...</p>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<FamilyTreeApp />);
  </script>
</body>
</html>
