<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Family Tree App</title>
<style>
  /* Reset and basics */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0; height: 100%;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #eef2f7;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  #login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex: 1;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
  }
  #login-box {
    background: rgba(255 255 255 / 0.15);
    border-radius: 12px;
    padding: 2rem 3rem;
    backdrop-filter: blur(10px);
    box-shadow: 0 8px 32px rgba(0,0,0,0.25);
    width: 320px;
  }
  #login-box h2 {
    margin-bottom: 1rem;
    font-weight: 700;
    text-align: center;
    letter-spacing: 1.5px;
  }
  #login-box input {
    width: 100%;
    padding: 0.75rem 1rem;
    margin-bottom: 1rem;
    border-radius: 8px;
    border: none;
    outline: none;
    font-size: 1rem;
  }
  #login-box button {
    width: 100%;
    padding: 0.75rem;
    background: #764ba2;
    border: none;
    border-radius: 8px;
    color: white;
    font-weight: 700;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  #login-box button:hover {
    background: #667eea;
  }

  /* App container */
  #app {
    display: flex;
    flex-direction: row;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  /* Sidebar for connections */
  #connections {
    width: 250px;
    background: #fff;
    border-left: 1px solid #ddd;
    overflow-y: auto;
    padding: 1rem;
  }

  /* Family tree container */
  #tree-container {
    flex: 1;
    overflow: auto;
    padding: 1rem;
    position: relative;
    min-width: 320px;
  }

  /* Node container */
  .node {
    background: white;
    border-radius: 8px;
    box-shadow: 0 1px 6px rgba(0,0,0,0.15);
    padding: 10px 15px;
    margin: 12px;
    min-width: 180px;
    cursor: default;
    user-select: none;
    position: relative;
  }
  .node .name {
    font-weight: 700;
    font-size: 1.1rem;
  }
  .node .dates {
    font-size: 0.9rem;
    color: #555;
    margin-bottom: 8px;
  }
  .node input {
    font-size: 0.9rem;
    margin-bottom: 6px;
    width: 100%;
    box-sizing: border-box;
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #ccc;
  }
  .node button {
    font-size: 0.8rem;
    padding: 4px 8px;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    margin-right: 6px;
    background: #667eea;
    color: white;
  }
  .node button.delete {
    background: #e74c3c;
  }
  .node button:hover {
    opacity: 0.9;
  }

  /* Spouses container */
  .spouses {
    display: flex;
    gap: 16px;
    margin-top: 10px;
  }

  /* Children container */
  .children {
    border-left: 2px solid #667eea;
    margin-left: 20px;
    padding-left: 20px;
    margin-top: 15px;
  }

  /* Connection lines container */
  svg#connections-svg {
    position: absolute;
    top: 0; left: 0; 
    width: 100%; height: 100%;
    pointer-events: none;
  }

  /* Footer */
  footer {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    background: rgba(255 255 255 / 0.15);
    backdrop-filter: blur(10px);
    color: #444;
    font-weight: 600;
    text-align: center;
    padding: 0.7rem;
    font-size: 0.9rem;
    border-top: 1px solid rgba(100, 100, 100, 0.1);
    z-index: 1000;
  }

  /* Responsive */
  @media (max-width: 768px) {
    #app {
      flex-direction: column;
    }
    #connections {
      width: 100%;
      height: 180px;
      border-left: none;
      border-top: 1px solid #ddd;
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      padding: 0.5rem 1rem;
    }
    #tree-container {
      flex: none;
      height: calc(100vh - 240px);
      padding: 0.5rem;
    }
    .node {
      min-width: 150px;
      margin: 10px 8px;
    }
    .spouses {
      flex-wrap: nowrap;
      overflow-x: auto;
    }
    .children {
      margin-left: 10px;
      padding-left: 10px;
      border-left-width: 1px;
    }
  }
</style>
</head>
<body>

<!-- LOGIN -->
<div id="login-container">
  <div id="login-box">
    <h2>Login</h2>
    <input type="email" id="email" placeholder="Email" autocomplete="username" />
    <input type="password" id="password" placeholder="Password" autocomplete="current-password" />
    <button id="login-btn">Log In</button>
    <p id="login-error" style="color:#e74c3c; display:none; font-size:0.9rem;"></p>
  </div>
</div>

<!-- APP -->
<div id="app" style="display:none;">
  <div id="tree-container">
    <svg id="connections-svg"></svg>
  </div>
  <div id="connections">
    <h3>Connections</h3>
    <div id="connections-list"></div>
  </div>
</div>

<footer>&copy; 2025 Maki Web. All rights reserved</footer>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
<script>
  // Your Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyCy9CKJ6CELheBhw7Gs0BgsE1E0FsoYdgU",
    authDomain: "project-955237504610034331.firebaseapp.com",
    databaseURL: "https://project-955237504610034331-default-rtdb.firebaseio.com",
    projectId: "project-955237504610034331",
    storageBucket: "project-955237504610034331.firebasestorage.app",
    messagingSenderId: "76212939677",
    appId: "1:76212939677:web:cc36cc1cadfd106b6e5d74",
    measurementId: "G-RCJ4P82PVM"
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.database();

  // Elements
  const loginContainer = document.getElementById('login-container');
  const appContainer = document.getElementById('app');
  const loginBtn = document.getElementById('login-btn');
  const emailInput = document.getElementById('email');
  const passwordInput = document.getElementById('password');
  const loginError = document.getElementById('login-error');

  // State
  let familyTrees = {};

  // Login handler
  loginBtn.addEventListener('click', () => {
    loginError.style.display = 'none';
    const email = emailInput.value.trim();
    const password = passwordInput.value;
    if (!email || !password) {
      loginError.textContent = 'Please enter email and password.';
      loginError.style.display = 'block';
      return;
    }
    auth.signInWithEmailAndPassword(email, password)
      .then(() => {
        loginContainer.style.display = 'none';
        appContainer.style.display = 'flex';
        listenFamilyTree();
      })
      .catch(err => {
        loginError.textContent = err.message;
        loginError.style.display = 'block';
      });
  });

  // Listen auth state
  auth.onAuthStateChanged(user => {
    if (user) {
      loginContainer.style.display = 'none';
      appContainer.style.display = 'flex';
      listenFamilyTree();
    } else {
      loginContainer.style.display = 'flex';
      appContainer.style.display = 'none';
    }
  });

  // Listen familyTrees from RTDB
  function listenFamilyTree() {
    const user = auth.currentUser;
    if (!user) return;

    const ref = db.ref('users/' + user.uid + '/familyTrees');
    ref.on('value', snapshot => {
      familyTrees = snapshot.val() || {};
      renderFamilyTrees();
    });
  }

  // Save familyTrees
  function saveFamilyTrees() {
    const user = auth.currentUser;
    if (!user) return;
    db.ref('users/' + user.uid + '/familyTrees').set(familyTrees);
  }

  // Generate unique ID
  function generateId() {
    return '_' + Math.random().toString(36).substr(2, 9);
  }

  // Recursive find node anywhere in tree, returns {node, parent, key, container}
  function findNodeById(nodeId, tree = familyTrees, parent = null, container = null) {
    for (const id in tree) {
      if (id === nodeId) return { node: tree[id], parent, key: id, container: tree };

      const node = tree[id];
      if (node.spouses) {
        for (const sid in node.spouses) {
          if (sid === nodeId) return { node: node.spouses[sid], parent: node.spouses, key: sid, container: node.spouses };

          const spouse = node.spouses[sid];
          if (spouse.children) {
            const found = findNodeById(nodeId, spouse.children, spouse, spouse.children);
            if (found) return found;
          }
        }
      }
    }
    return null;
  }

  // Add child to a spouse node
  function addChild(spouseId) {
    const found = findNodeById(spouseId);
    if (!found) return;
    const { node } = found;

    if (!node.children) node.children = {};
    const newChildId = generateId();
    node.children[newChildId] = {
      name: '',
      born: '',
      died: '',
      spouses: {}
    };
    saveFamilyTrees();
  }

  // Add spouse to a node (can be root or child)
  function addSpouse(nodeId) {
    const found = findNodeById(nodeId);
    if (!found) return;
    const { node } = found;
    if (!node.spouses) node.spouses = {};
    const newSpouseId = generateId();
    node.spouses[newSpouseId] = {
      name: '',
      born: '',
      died: '',
      children: {}
    };
    saveFamilyTrees();
  }

  // Delete a node (from root or nested)
  function deleteNode(nodeId) {
    const found = findNodeById(nodeId);
    if (!found) return;
    const { parent, key, container } = found;
    if (container && key) {
      delete container[key];
      saveFamilyTrees();
    }
  }

  // Update node property
  function updateNodeField(nodeId, field, value) {
    const found = findNodeById(nodeId);
    if (!found) return;
    const { node } = found;
    node[field] = value;
    saveFamilyTrees();
  }

  // Create node HTML recursively
  function createNodeElement(node, nodeId) {
    const nodeEl = document.createElement('div');
    nodeEl.className = 'node';
    nodeEl.dataset.id = nodeId;

    // Name input
    const nameInput = document.createElement('input');
    nameInput.placeholder = 'Name';
    nameInput.value = node.name || '';
    nameInput.addEventListener('input', e => updateNodeField(nodeId, 'name', e.target.value));
    nodeEl.appendChild(nameInput);

    // Born input
    const bornInput = document.createElement('input');
    bornInput.placeholder = 'Born (YYYY)';
    bornInput.value = node.born || '';
    bornInput.type = 'number';
    bornInput.min = 1000;
    bornInput.max = new Date().getFullYear();
    bornInput.addEventListener('input', e => updateNodeField(nodeId, 'born', e.target.value));
    nodeEl.appendChild(bornInput);

    // Died input
    const diedInput = document.createElement('input');
    diedInput.placeholder = 'Died (YYYY)';
    diedInput.value = node.died || '';
    diedInput.type = 'number';
    diedInput.min = 1000;
    diedInput.max = new Date().getFullYear();
    diedInput.addEventListener('input', e => updateNodeField(nodeId, 'died', e.target.value));
    nodeEl.appendChild(diedInput);

    // Buttons container
    const btns = document.createElement('div');
    btns.style.marginTop = '6px';

    // Add spouse button
    const addSpouseBtn = document.createElement('button');
    addSpouseBtn.textContent = 'Add Spouse';
    addSpouseBtn.addEventListener('click', () => addSpouse(nodeId));
    btns.appendChild(addSpouseBtn);

    // Add child button (only if node is spouse)
    if ('children' in node) {
      const addChildBtn = document.createElement('button');
      addChildBtn.textContent = 'Add Child';
      addChildBtn.addEventListener('click', () => addChild(nodeId));
      btns.appendChild(addChildBtn);
    }

    // Delete button (can't delete root if only one root)
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'delete';
    deleteBtn.addEventListener('click', () => {
      if (confirm('Delete this member?')) {
        deleteNode(nodeId);
      }
    });
    btns.appendChild(deleteBtn);

    nodeEl.appendChild(btns);

    // Spouses container
    if (node.spouses && Object.keys(node.spouses).length > 0) {
      const spousesDiv = document.createElement('div');
      spousesDiv.className = 'spouses';

      for (const spouseId in node.spouses) {
        const spouseNode = node.spouses[spouseId];
        const spouseEl = createNodeElement(spouseNode, spouseId);
        spousesDiv.appendChild(spouseEl);
      }
      nodeEl.appendChild(spousesDiv);
    }

    // Children container (only for spouses)
    if (node.children && Object.keys(node.children).length > 0) {
      const childrenDiv = document.createElement('div');
      childrenDiv.className = 'children';

      for (const childId in node.children) {
        const childNode = node.children[childId];
        const childEl = createNodeElement(childNode, childId);
        childrenDiv.appendChild(childEl);
      }
      nodeEl.appendChild(childrenDiv);
    }

    return nodeEl;
  }

  // Render family tree in #tree-container
  function renderFamilyTrees() {
    const container = document.getElementById('tree-container');
    container.innerHTML = '<svg id="connections-svg"></svg>';
    const svg = container.querySelector('#connections-svg');

    // Create a wrapper div for layout
    const wrapper = document.createElement('div');
    wrapper.style.display = 'flex';
    wrapper.style.flexWrap = 'wrap';
    wrapper.style.gap = '40px';
    container.appendChild(wrapper);

    for (const rootId in familyTrees) {
      const rootNode = familyTrees[rootId];
      const rootEl = createNodeElement(rootNode, rootId);
      wrapper.appendChild(rootEl);
    }

    setTimeout(() => {
      drawConnections();
      renderConnectionsList();
    }, 100); // slight delay so elements render
  }

  // Draw connections between nodes with SVG lines/arrows
  function drawConnections() {
    const svg = document.getElementById('connections-svg');
    svg.innerHTML = '';

    // Helper to get center-bottom coords of element
    function getBottomCenter(el) {
      const rect = el.getBoundingClientRect();
      const containerRect = svg.parentElement.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2 - containerRect.left,
        y: rect.top + rect.height - containerRect.top
      };
    }
    // Helper to get center-top coords of element
    function getTopCenter(el) {
      const rect = el.getBoundingClientRect();
      const containerRect = svg.parentElement.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2 - containerRect.left,
        y: rect.top - containerRect.top
      };
    }

    // Recursive function to connect spouses and children
    function connectNode(nodeEl) {
      if (!nodeEl) return;

      const spousesContainer = nodeEl.querySelector('.spouses');
      if (spousesContainer) {
        // Connect spouses side by side with line
        const spouseEls = spousesContainer.children;
        const parentBottom = getBottomCenter(nodeEl);
        for (let i = 0; i < spouseEls.length; i++) {
          const spouseEl = spouseEls[i];
          // Draw line from root node bottom center to spouse top center
          const spouseTop = getTopCenter(spouseEl);
          drawLine(svg, parentBottom.x, parentBottom.y, spouseTop.x, spouseTop.y);

          // Connect spouses next to each other with line
          if (i < spouseEls.length - 1) {
            const curRight = spouseEls[i].getBoundingClientRect().right - svg.parentElement.getBoundingClientRect().left;
            const nextLeft = spouseEls[i+1].getBoundingClientRect().left - svg.parentElement.getBoundingClientRect().left;
            const y = spouseTop.y - 10;
            drawLine(svg, curRight, y, nextLeft, y);
          }

          // For each spouse, connect their children
          const childrenContainer = spouseEl.querySelector('.children');
          if (childrenContainer) {
            for (const childEl of childrenContainer.children) {
              const spouseBottom = getBottomCenter(spouseEl);
              const childTop = getTopCenter(childEl);
              drawLine(svg, spouseBottom.x, spouseBottom.y, childTop.x, childTop.y);

              // Recursive connect children nodes
              connectNode(childEl);
            }
          }
        }
      }
      // If no spouses, still connect children if any
      else {
        const childrenContainer = nodeEl.querySelector('.children');
        if (childrenContainer) {
          for (const childEl of childrenContainer.children) {
            const parentBottom = getBottomCenter(nodeEl);
            const childTop = getTopCenter(childEl);
            drawLine(svg, parentBottom.x, parentBottom.y, childTop.x, childTop.y);
            connectNode(childEl);
          }
        }
      }
    }

    // Draw lines for all roots
    const wrapper = svg.parentElement.querySelector('div');
    for (const child of wrapper.children) {
      connectNode(child);
    }
  }

  // Draw a simple SVG line with arrow marker
  function drawLine(svg, x1, y1, x2, y2) {
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', '#667eea');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('marker-end', 'url(#arrow)');

    // Define arrow marker only once
    if (!svg.querySelector('#arrow')) {
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id', 'arrow');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '6');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      marker.setAttribute('markerUnits', 'strokeWidth');

      const path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.setAttribute('d', 'M0,0 L6,3 L0,6');
      path.setAttribute('fill', '#667eea');
      marker.appendChild(path);
      defs.appendChild(marker);
      svg.appendChild(defs);
    }
    svg.appendChild(line);
  }

  // Render connections list on side panel
  function renderConnectionsList() {
    const listContainer = document.getElementById('connections-list');
    listContainer.innerHTML = '';

    // Flatten tree to list members with their spouses and children
    function flatten(tree, arr = []) {
      for (const id in tree) {
        const node = tree[id];
        arr.push({ id, ...node });
        if (node.spouses) {
          for (const sid in node.spouses) {
            arr.push({ id: sid, ...node.spouses[sid] });
            if (node.spouses[sid].children) {
              flatten(node.spouses[sid].children, arr);
            }
          }
        }
      }
      return arr;
    }

    const members = flatten(familyTrees);

    if (members.length === 0) {
      listContainer.textContent = 'No family members yet.';
      return;
    }

    for (const member of members) {
      const div = document.createElement('div');
      div.style.marginBottom = '8px';

      const name = member.name || '(Unnamed)';
      const born = member.born ? `Born: ${member.born}` : '';
      const died = member.died ? `Died: ${member.died}` : '';
      div.textContent = `${name} ${born} ${died}`.trim();
      listContainer.appendChild(div);
    }
  }

  // INITIALIZE with sample data if none exists
  auth.onAuthStateChanged(user => {
    if (!user) return;
    if (!familyTrees || Object.keys(familyTrees).length === 0) {
      familyTrees = {
        root: {
          name: 'John Doe',
          born: '1950',
          died: '',
          spouses: {
            spouse1: {
              name: 'Jane Doe',
              born: '1952',
              died: '',
              children: {
                child1: {
                  name: 'Mike Doe',
                  born: '1975',
                  died: '',
                  spouses: {}
                },
                child2: {
                  name: 'Anna Doe',
                  born: '1978',
                  died: '',
                  spouses: {}
                }
              }
            }
          }
        }
      };
      saveFamilyTrees();
    }
  });
</script>
</body>
</html>
