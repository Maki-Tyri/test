<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Classic Family Tree Style</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    font-family: monospace, monospace;
    background: #f8f8f8;
  }
  #app {
    height: 100vh;
    overflow: auto;
    padding: 20px;
    box-sizing: border-box;
    background: #fff;
    white-space: nowrap;
  }
  .node {
    display: inline-block;
    position: relative;
    vertical-align: top;
    margin: 8px 20px;
    padding: 10px 15px;
    background: #e0e7ff;
    border-radius: 8px;
    border: 1px solid #667eea;
    min-width: 240px;
    box-shadow: 1px 2px 5px rgba(100,100,200,0.2);
  }
  .node.spouse {
    background: #ffe0e0;
    border-color: #ee6677;
  }
  .node > input[type="text"], .node > input[type="date"] {
    width: 100%;
    margin: 4px 0;
    font-family: monospace;
    font-size: 0.85em;
    box-sizing: border-box;
  }
  .controls {
    margin-top: 6px;
  }
  .controls button {
    margin-right: 8px;
    font-size: 0.85em;
    cursor: pointer;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 4px 8px;
  }
  .controls button:hover {
    background: #4353c8;
  }
  .tree {
    display: flex;
    flex-direction: column;
    position: relative;
  }
  .children {
    display: flex;
    margin-left: 40px;
    border-left: 2px solid #667eea;
    padding-left: 20px;
  }
  /* Lines connecting spouses */
  .spouse-container {
    display: flex;
    align-items: center;
    margin-top: 6px;
  }
  .spouse-line {
    height: 2px;
    background: #ee6677;
    flex-grow: 1;
    margin: 0 6px;
  }
  /* Connector vertical line between parent and children */
  .connector-vertical {
    position: absolute;
    width: 2px;
    background: #667eea;
  }
  /* Highlight searched node */
  .highlight {
    animation: blink 1s infinite alternate;
    border-color: #ff9933 !important;
    box-shadow: 0 0 8px 2px #ff9933;
  }
  @keyframes blink {
    from { box-shadow: 0 0 8px 2px #ff9933; }
    to { box-shadow: none; }
  }
</style>
</head>
<body>

<div style="position:fixed;top:10px;left:10px;z-index:10;background:#fff;padding:8px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.2);">
  <input id="searchInput" type="text" placeholder="Search name..." style="font-family: monospace; font-size:1em; padding:4px;" />
  <button onclick="addRoot()" style="margin-left:12px;cursor:pointer;">Add Root</button>
</div>

<div id="app"></div>

<script>
  // Tree data model
  let nodeIdCounter = 0;
  function createNode(parent=null) {
    return {
      id: "node-" + nodeIdCounter++,
      name: "",
      birthday: "",
      death: "",
      parent: parent, // reference to parent node or null if root
      spouse: null,   // reference to spouse node or null
      children: [],
      collapsed: false,
    };
  }

  let roots = [];

  // Helper: find node by id recursively
  function findNodeById(node, id) {
    if (node.id === id) return node;
    for (const child of node.children) {
      let found = findNodeById(child, id);
      if (found) return found;
    }
    if (node.spouse) {
      if (node.spouse.id === id) return node.spouse;
    }
    return null;
  }
  function findNodeByIdInRoots(id) {
    for (const root of roots) {
      let found = findNodeById(root, id);
      if (found) return found;
    }
    return null;
  }

  // Add root
  function addRoot() {
    const root = createNode();
    roots.push(root);
    render();
  }

  // Add child to a node
  function addChild(node) {
    const child = createNode(node);
    node.children.push(child);
    render();
  }

  // Add spouse to a node
  function addSpouse(node) {
    if (node.spouse !== null) {
      alert("Spouse already exists!");
      return;
    }
    const spouse = createNode(node.parent);
    node.spouse = spouse;
    spouse.spouse = node;
    // Spouse shares same parent as node, so add to parent's children if exists
    if (node.parent) {
      node.parent.children.push(spouse);
    } else {
      // If no parent (root node), add spouse as another root for layout purposes
      roots.push(spouse);
    }
    render();
  }

  // Toggle collapse children
  function toggleCollapse(node) {
    node.collapsed = !node.collapsed;
    render();
  }

  // Render tree recursively
  function renderNode(node, container) {
    const nodeDiv = document.createElement("div");
    nodeDiv.classList.add("node");
    nodeDiv.id = node.id;

    // Input fields
    nodeDiv.innerHTML = `
      <input type="text" placeholder="Name" value="${node.name}" />
      <input type="date" value="${node.birthday}" />
      <input type="date" value="${node.death}" />
      <div class="controls">
        <button class="add-child">Add Child</button>
        <button class="add-spouse">Add Spouse</button>
        <button class="toggle-collapse">${node.collapsed ? "Expand" : "Collapse"}</button>
      </div>
    `;

    // Input event listeners
    const inputs = nodeDiv.querySelectorAll("input");
    inputs[0].addEventListener("input", e => {
      node.name = e.target.value;
    });
    inputs[1].addEventListener("input", e => {
      node.birthday = e.target.value;
    });
    inputs[2].addEventListener("input", e => {
      node.death = e.target.value;
    });

    // Button events
    nodeDiv.querySelector(".add-child").onclick = () => addChild(node);
    nodeDiv.querySelector(".add-spouse").onclick = () => addSpouse(node);
    nodeDiv.querySelector(".toggle-collapse").onclick = () => toggleCollapse(node);

    container.appendChild(nodeDiv);

    // Spouse rendering
    if (node.spouse && !container.querySelector(`#${node.spouse.id}`)) {
      // Spouse container with line
      const spouseContainer = document.createElement("div");
      spouseContainer.className = "spouse-container";

      const spouseDiv = document.createElement("div");
      spouseDiv.classList.add("node", "spouse");
      spouseDiv.id = node.spouse.id;
      spouseDiv.innerHTML = `
        <input type="text" placeholder="Name" value="${node.spouse.name}" />
        <input type="date" value="${node.spouse.birthday}" />
        <input type="date" value="${node.spouse.death}" />
        <div class="controls">
          <button class="add-child">Add Child</button>
          <button class="toggle-collapse">${node.spouse.collapsed ? "Expand" : "Collapse"}</button>
        </div>
      `;

      // Inputs spouse
      const sInputs = spouseDiv.querySelectorAll("input");
      sInputs[0].addEventListener("input", e => {
        node.spouse.name = e.target.value;
      });
      sInputs[1].addEventListener("input", e => {
        node.spouse.birthday = e.target.value;
      });
      sInputs[2].addEventListener("input", e => {
        node.spouse.death = e.target.value;
      });

      // Buttons spouse
      spouseDiv.querySelector(".add-child").onclick = () => addChild(node.spouse);
      spouseDiv.querySelector(".toggle-collapse").onclick = () => toggleCollapse(node.spouse);

      // Add line between spouses
      const line = document.createElement("div");
      line.className = "spouse-line";

      spouseContainer.appendChild(line);
      spouseContainer.appendChild(spouseDiv);

      container.appendChild(spouseContainer);
    }

    // Children container
    if (node.children.length > 0 && !node.collapsed) {
      const childrenDiv = document.createElement("div");
      childrenDiv.className = "children";
      container.appendChild(childrenDiv);

      for (const child of node.children) {
        renderNode(child, childrenDiv);
      }
    }
  }

  // Render all roots
  function render() {
    const app = document.getElementById("app");
    app.innerHTML = "";

    for (const root of roots) {
      renderNode(root, app);
    }

    highlightSearchResults();
  }

  // Search & highlight
  const searchInput = document.getElementById("searchInput");
  searchInput.addEventListener("input", () => {
    highlightSearchResults();
  });

  function highlightSearchResults() {
    const term = searchInput.value.toLowerCase();
    if (term === "") {
      document.querySelectorAll(".node").forEach(n => n.classList.remove("highlight"));
      return;
    }

    // Expand ancestors of matched nodes
    function expandAncestors(node) {
      if (node.parent) {
        node.parent.collapsed = false;
        expandAncestors(node.parent);
      }
    }

    // Clear highlights
    document.querySelectorAll(".node").forEach(n => n.classList.remove("highlight"));

    // Highlight matching nodes and expand parents
    function checkNode(node) {
      let matched = node.name.toLowerCase().includes(term);
      if (matched) {
        const nodeDiv = document.getElementById(node.id);
        if (nodeDiv) nodeDiv.classList.add("highlight");
        expandAncestors(node);
      }
      if (node.spouse) {
        if (node.spouse.name.toLowerCase().includes(term)) {
          const spouseDiv = document.getElementById(node.spouse.id);
          if (spouseDiv) spouseDiv.classList.add("highlight");
          expandAncestors(node.spouse);
          matched = true;
        }
      }
      node.children.forEach(c => checkNode(c));
    }
    roots.forEach(r => checkNode(r));
    render(); // re-render after expansion
  }

  // Start with one root by default
  addRoot();
</script>

</body>
</html>
